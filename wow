-- tsunami for brainroot
-- v1.0.5

-- ===================== SERVICES =====================
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")
local Debris = game:GetService("Debris")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local RS = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local StarterGui = game:GetService("StarterGui")
local player = Players.LocalPlayer

-- ===================== CONFIG =====================
local CHECK_INTERVAL = 0.03
local GROUND_OFFSET = 3
local SAFE_DISTANCE = 50
local DETECTION_DISTANCE = 120
local TWEEN_SPEED = 500
local FORCE_BACK_SPEED = 300

-- ===================== GAP SETUP =====================
local GAPS = {
    {Name="Gap1",Part=Workspace.Misc.Gaps.Gap1:GetChildren()[2]},
    {Name="Gap2",Part=Workspace.Misc.Gaps.Gap2:GetChildren()[2]},
    {Name="Gap3",Part=Workspace.Misc.Gaps.Gap3:GetChildren()[2]},
    {Name="Gap4",Part=Workspace.Misc.Gaps.Gap4:GetChildren()[2]},
    {Name="Gap5",Part=Workspace.Misc.Gaps.Gap5:GetChildren()[2]},
    {Name="Gap6",Part=Workspace.Misc.Gaps.Gap6.Mud},
    {Name="Gap7",Part=Workspace.Misc.Gaps.Gap7:GetChildren()[2]},
    {Name="Gap8",Part=Workspace.Misc.Gaps.Gap8:GetChildren()[2]},
    {Name="Gap9",Part=Workspace.Misc.Gaps.Gap9:GetChildren()[2]},
}

-- Gap to rarity mapping
local GAP_TO_RARITY = {
    ["Gap1"] = "Common",
    ["Gap2"] = "Uncommon",
    ["Gap3"] = "Rare",
    ["Gap4"] = "Epic",
    ["Gap5"] = "Legendary",
    ["Gap6"] = "Mythical",
    ["Gap7"] = "Cosmic",
    ["Gap8"] = "Secret",
    ["Gap9"] = "Celestial"
}

-- Home coordinates
local HOME_POSITION = CFrame.new(121, 3, 39)

-- ===================== UTILS =====================
local function getChar()
    return player.Character or player.CharacterAdded:Wait()
end

local function getHRP()
    return getChar():WaitForChild("HumanoidRootPart")
end

local function getHumanoid()
    return getChar():FindFirstChild("Humanoid")
end

local function getGroundCFrame(pos)
    return CFrame.new(pos.X, pos.Y + GROUND_OFFSET, pos.Z)
end

local function teleportToPosition(pos)
    local hrp = getHRP()
    hrp.CFrame = getGroundCFrame(pos)
end

local function instantTeleportToPosition(pos)
    local hrp = getHRP()
    hrp.CFrame = CFrame.new(pos)
end

-- ===================== TSUNAMI =====================
local function getNearestTsunami()
    local folder = Workspace:FindFirstChild("ActiveTsunamis")
    if not folder then return nil end

    local hrp = getHRP()
    local nearest, dist = nil, math.huge

    for _, w in ipairs(folder:GetChildren()) do
        local hb = w:FindFirstChild("Hitbox", true)
        if hb then
            local d = (hb.Position - hrp.Position).Magnitude
            if d < dist then
                dist = d
                nearest = hb
            end
        end
    end
    return nearest
end

-- Check tsunami dengan detection lebih jauh (proaktif)
local function isTsunamiNear(pos)
    local tsu = getNearestTsunami()
    if not tsu then return false end
    return (tsu.Position - pos).Magnitude <= DETECTION_DISTANCE
end

local function tsunamiOnPath(startPos, endPos) -- Fungsi lama, bisa dihapus atau dibiarkan untuk kompatibilitas
    return isTsunamiNear(startPos) or isTsunamiNear(endPos)
end

-- ===================== GAP PATH =====================
local function gapPathTo(target)
    local hrp = getHRP()
    local path = {}

    for _, g in ipairs(GAPS) do
        if g.Part.Position.X >= hrp.Position.X
        and g.Part.Position.X <= target.Part.Position.X then
            table.insert(path, g)
        end
    end

    table.sort(path, function(a,b)
        return a.Part.Position.X < b.Part.Position.X
    end)

    return path
end

-- ===================== FORCE BACK =====================
local function getNearestGap(currentPos)
    local nearest = nil
    local minDist = math.huge
    
    for _, gap in ipairs(GAPS) do
        local dist = (gap.Part.Position - currentPos).Magnitude
        if dist < minDist and dist > 2 then
            minDist = dist
            nearest = gap
        end
    end
    
    return nearest, minDist
end

local function forceBackWithTween()
    local hrp = getHRP()
    local humanoid = getHumanoid()
    local currentPos = hrp.Position
    
    local nearestGap, gapDist = getNearestGap(currentPos)
    
    if nearestGap then
        local targetCF = getGroundCFrame(nearestGap.Part.Position)
        
        local tween = TweenService:Create(
            hrp,
            TweenInfo.new(gapDist / FORCE_BACK_SPEED, Enum.EasingStyle.Linear),
            {CFrame = targetCF}
        )
        tween:Play()
        
        local startTime = tick()
        while tween.PlaybackState == Enum.PlaybackState.Playing do
            hrp.Velocity = Vector3.zero
            if humanoid then humanoid.Jump = false end
            if tick() - startTime > (gapDist / FORCE_BACK_SPEED + 1) then
                tween:Cancel()
                hrp.CFrame = targetCF
                break
            end
            task.wait(CHECK_INTERVAL)
        end
    end
end

-- ===================== SMART MOVE =====================
local function smartMove(target, flag, speed, statusParagraph)
    local hrp = getHRP()
    local humanoid = getHumanoid()
    local path = target.Part and gapPathTo(target) or {}
    if target.Position then path = {} end
    table.insert(path, {Part = target.Part or target})
    
    local i = 1
    while i <= #path and flag.Value do
        local gap = path[i]
        
        -- Tunggu aman dari tsunami
        while isTsunamiNear(hrp.Position) and flag.Value do
            hrp.Velocity = Vector3.zero
            if humanoid then humanoid.Jump = false end
            forceBackWithTween()
            if statusParagraph then statusParagraph:SetDesc("Tsunami detected! Waiting...") end
            task.wait(CHECK_INTERVAL)
        end
        
        -- Tween ke target
        local dist = (hrp.Position - gap.Part.Position).Magnitude
        local targetCF = getGroundCFrame(gap.Part.Position)
        local tween = TweenService:Create(hrp, TweenInfo.new(dist / speed, Enum.EasingStyle.Linear), {CFrame = targetCF})
        tween:Play()
        
        local startTime = tick()
        while tween.PlaybackState == Enum.PlaybackState.Playing do
            if not flag.Value then 
                tween:Cancel() 
                return 
            end
            
            hrp.Velocity = Vector3.zero
            if humanoid then humanoid.Jump = false end
            
            if isTsunamiNear(hrp.Position) then
                tween:Cancel()
                forceBackWithTween()
                break
            end
            
            if tick() - startTime > dist / speed + 2 then
                tween:Cancel()
                hrp.CFrame = targetCF
                break
            end
            task.wait(CHECK_INTERVAL)
        end
        i += 1
    end
end

-- ===================== BRAINROOT FUNCTIONS =====================
local function waitForBrainroot(rarity)
    local brainroots = Workspace:FindFirstChild("ActiveBrainrots")
    if not brainroots then return false end
    local folder = brainroots:FindFirstChild(rarity)
    if not folder then return false end
    local startTime = tick()
    local timeout = 30
    while #folder:GetChildren() == 0 and tick() - startTime < timeout do task.wait(1) end
    return #folder:GetChildren() > 0
end

local function getHighestIncomeBrainroot(rarity)
    local brainroots = Workspace:FindFirstChild("ActiveBrainrots")
    if not brainroots then return nil end
    local folder = brainroots:FindFirstChild(rarity)
    if not folder then return nil end
    local highestIncome = 0
    local targetBrainroot = nil
    for _, b in pairs(folder:GetChildren()) do
        if b:IsA("Model") then
            local income = 0
            for _, c in ipairs(b:GetDescendants()) do
                if c:IsA("TextLabel") and c.Text:find("%$") then
                    local amount = c.Text:match("%$(.+)%/s")
                    if amount then income = tonumber(amount) or 0; break end
                end
            end
            if income > highestIncome then
                highestIncome = income
                targetBrainroot = b
            end
        end
    end
    return targetBrainroot
end

-- ===================== COLLECT BRAINROOT SAFE =====================
local function collectBrainroot(brainroot, statusParagraph)
    if not brainroot then return false end
    local targetPart = brainroot.PrimaryPart or brainroot:FindFirstChildWhichIsA("BasePart")
    if not targetPart then return false end
    local hrp = getHRP()
    local humanoid = getHumanoid()
    local flag = {Value = true}

    if statusParagraph then statusParagraph:SetDesc("Moving to brainroot...") end
    -- Move ke brainroot
    smartMove({Part = targetPart}, flag, TWEEN_SPEED, statusParagraph)

    if not flag.Value then return false end

    -- Hold E dengan realtime tsunami check
    if statusParagraph then statusParagraph:SetDesc("Collecting brainroot...") end
    local holdTime = 2
    local startHold = tick()
    while tick() - startHold < holdTime do
        if isTsunamiNear(hrp.Position) then
            if statusParagraph then statusParagraph:SetDesc("Tsunami detected! Waiting...") end
            forceBackWithTween()
            task.wait(0.5)
            startHold = tick() -- Reset timer
        else
            hrp.Velocity = Vector3.zero
            if humanoid then humanoid.Jump = false end
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(CHECK_INTERVAL)
        end
    end
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)

    -- Pulang ke home dengan smartMove (real-time tsunami)
    if statusParagraph then statusParagraph:SetDesc("Returning home...") end
    smartMove({Position = HOME_POSITION.Position}, {Value = true}, TWEEN_SPEED, statusParagraph)

    return true
end

-- ===================== AUTO FARM =====================
local function autoFarmBrainroot(rarity, statusParagraph)
    local gapName = nil
    for g, r in pairs(GAP_TO_RARITY) do 
        if r == rarity then 
            gapName = g 
            break 
        end 
    end
    
    if not gapName then 
        if statusParagraph then statusParagraph:SetDesc("Invalid rarity selected") end
        return false 
    end
    
    local targetGapData = nil
    for _, g in ipairs(GAPS) do 
        if g.Name == gapName then 
            targetGapData = g 
            break 
        end 
    end
    
    if not targetGapData then 
        if statusParagraph then statusParagraph:SetDesc("Gap not found for rarity: " .. rarity) end
        return false 
    end
    
    local flag = {Value = true}
    if statusParagraph then statusParagraph:SetDesc("Navigating to " .. gapName .. "...") end
    smartMove(targetGapData, flag, TWEEN_SPEED, statusParagraph)
    
    if not flag.Value then 
        if statusParagraph then statusParagraph:SetDesc("Navigation cancelled") end
        return false 
    end
    
    if not waitForBrainroot(rarity) then 
        if statusParagraph then statusParagraph:SetDesc("Timeout waiting for brainroot") end
        return false 
    end
    
    local targetBrainroot = getHighestIncomeBrainroot(rarity)
    if not targetBrainroot then 
        if statusParagraph then statusParagraph:SetDesc("No brainroot found") end
        return false 
    end
    
    return collectBrainroot(targetBrainroot, statusParagraph)
end

-- ===================== LUCKY BLOCK AUTO FARM (OPTIMIZED VERSION) =====================
local luckyBlockFarmEnabled = false
local selectedLuckyBlockRaritiesForFarm = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythical", "Cosmic", "Secret", "Celestial", "Divine"}
local luckyBlockFarmStatus = nil
local luckyBlockFarmFlag = {Value = false}
local selectedLuckyBlockType = "Common"

-- Priority system for Lucky Block rarities
local luckyBlockPriority = {
    ["Divine"] = 100,
    ["Celestial"] = 90,
    ["Secret"] = 80,
    ["Cosmic"] = 70,
    ["Mythical"] = 60,
    ["Legendary"] = 50,
    ["Epic"] = 40,
    ["Rare"] = 30,
    ["Uncommon"] = 20,
    ["Common"] = 10
}

local function getLuckyBlockRarity(obj)
    for rarity, _ in pairs(luckyBlockColors) do
        if string.find(obj.Name, rarity) then
            return rarity
        end
    end
    return nil
end

local function findNearestLuckyBlock()
    local folder = Workspace:FindFirstChild("ActiveLuckyBlocks")
    if not folder then return nil end
    
    local hrp = getHRP()
    local nearest = nil
    local minDist = math.huge
    
    for _, obj in ipairs(folder:GetChildren()) do
        local rarity = getLuckyBlockRarity(obj)
        if rarity and table.find(selectedLuckyBlockRaritiesForFarm, rarity) then
            local part = obj:IsA("BasePart") and obj or obj:FindFirstChildWhichIsA("BasePart")
            if part then
                local dist = (part.Position - hrp.Position).Magnitude
                if dist < minDist then
                    minDist = dist
                    nearest = {
                        Object = obj,
                        Rarity = rarity,
                        Position = part.Position,
                        Part = part
                    }
                end
            end
        end
    end
    
    return nearest
end

local function collectLuckyBlockSimple(luckyBlock)
    if not luckyBlock then return false end
    
    local hrp = getHRP()
    local humanoid = getHumanoid()
    if not hrp or not humanoid then return false end
    
    -- Move to position
    local targetPos = luckyBlock.Position + Vector3.new(0, 3, 0)
    hrp.CFrame = CFrame.new(targetPos)
    
    -- Wait a moment
    task.wait(0.5)
    
    -- Press E
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
    task.wait(0.2)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
    
    return true
end

-- ===================== SIMPLIFIED LUCKY BLOCK FARM LOOP =====================
local function startSimpleLuckyBlockFarm()
    task.spawn(function()
        while luckyBlockFarmEnabled do
            if not luckyBlockFarmFlag.Value then
                task.wait(1)
                continue
            end
            
            local target = findNearestLuckyBlock()
            if target then
                if luckyBlockFarmStatus then
                    luckyBlockFarmStatus:SetDesc("Moving to " .. target.Rarity .. " Lucky Block...")
                end
                
                -- Check for tsunami
                if isTsunamiNear(getHRP().Position) then
                    if luckyBlockFarmStatus then
                        luckyBlockFarmStatus:SetDesc("Tsunami detected! Waiting...")
                    end
                    forceBackWithTween()
                    task.wait(2)
                    continue
                end
                
                -- Collect the block
                local success = collectLuckyBlockSimple(target)
                
                if success then
                    if luckyBlockFarmStatus then
                        luckyBlockFarmStatus:SetDesc("Collected " .. target.Rarity .. "! Returning home...")
                    end
                    
                    -- Return home
                    task.wait(1)
                    teleportToPosition(HOME_POSITION.Position)
                    
                    if luckyBlockFarmStatus then
                        luckyBlockFarmStatus:SetDesc("Waiting for next Lucky Block...")
                    end
                    
                    task.wait(3)
                else
                    if luckyBlockFarmStatus then
                        luckyBlockFarmStatus:SetDesc("Failed to collect. Retrying...")
                    end
                    task.wait(2)
                end
            else
                if luckyBlockFarmStatus then
                    luckyBlockFarmStatus:SetDesc("No Lucky Blocks found...")
                end
                task.wait(5)
            end
        end
        
        if luckyBlockFarmStatus then
            luckyBlockFarmStatus:SetDesc("Stopped")
        end
    end)
end

-- ===================== WINDUI SETUP =====================
local WindUI
local maxRetries = 3
for attempt = 1, maxRetries do
    local success, result = pcall(function()
        return loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"))()
    end)
 
    if success and result then
        WindUI = result
        break
    else
        if attempt < maxRetries then
            task.wait(2)
            local altSuccess, altResult = pcall(function()
                return loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/refs/heads/main/dist/main.lua"))()
            end)
            if altSuccess and altResult then
                WindUI = altResult
                break
            end
        end
    end
end

if not WindUI then
    WindUI = {
        Notify = function(options)
            StarterGui:SetCore("SendNotification", {
                Title = options.Title or "Notification",
                Text = options.Content or "",
                Duration = options.Duration or 3
            })
        end
    }
end

-- ESP Variables
local brainrootEspEnabled = false
local playerEspEnabled = false
local luckyBlockEspEnabled = false
local espObjects = {}
local espLabels = {}
local selectedFloorsForEsp = {"Common Floor", "Uncommon Floor", "Rare Floor", "Epic Floor", "Legendary Floor", "Mythical Floor", "Cosmic Floor", "Secret Floor", "Celestial Floor"}
local selectedLuckyBlockRarities = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythical", "Cosmic", "Secret", "Celestial", "Divine"}
local espUpdateConnection = nil
local brainrootMonitorConnection = nil

local luckyBlockColors = {
    ["Common"] = Color3.fromRGB(170,170,170),
    ["Uncommon"] = Color3.fromRGB(85,255,85),
    ["Rare"] = Color3.fromRGB(85,170,255),
    ["Epic"] = Color3.fromRGB(170,85,255),
    ["Legendary"] = Color3.fromRGB(255,170,0),
    ["Mythical"] = Color3.fromRGB(255,85,85),
    ["Cosmic"] = Color3.fromRGB(0,255,255),
    ["Secret"] = Color3.fromRGB(255,255,255),
    ["Celestial"] = Color3.fromRGB(255,0,255),
    ["Divine"] = Color3.fromRGB(204, 153, 0)
}

-- Variables
local noclipConn
local flyEnabled = false
local flying = false
local speed = 50
local flyConnection = nil

-- Auto Farm Variables
local collectMoneyEnabled = false
local upgradeBrainrotEnabled = false
local upgradeSpeedEnabled = false
local selectedSpeedValues = {"1", "5", "10"}
local selectedSlots = {}
local selectedUpgradeSlots = {}
local rebirthEnabled = false
local carryUpgradeEnabled = false
local sellBrainrootEnabled = false
local sellAllEnabled = false
local upgradeBaseEnabled = false
local checkPriceEnabled = false
local currentBrainrootPrice = 0
local instantTakeEnabled = false
local collectRadioactiveCoinsEnabled = false

-- Auto Farm Brainroot Variables
local autoFarmBrainrootEnabled = false
local selectedRarity = "Common"

-- Cylinder System Variables
local moneyCylinderSize = 5
local upgradeCylinderSize = 5
local coinCylinderSize = 10
local coinRadius = 3
local coinHeight = 2

-- Auto Spin Wheel Variables
local autoSpinEnabled = false
local spinCooldown = 1
local autoSpinInitialized = false

-- Hitbox Variables
local hitboxEnabled = false
local hitboxSize = 5
local hitboxColor = Color3.new(1, 0, 0)
local hitboxTransparency = 0.7
local hitboxParts = {}

-- Anti-Ragdoll Variables
local antiRagdollEnabled = false
local humanoidStateConn = nil

-- Radioactive Coins Variables
local coins = {}
local coinCollectionConnection = nil

-- Event Tracker Variables
local eventTrackerEnabled = true
local eventTrackerGui = nil
local celestialLabel = nil
local radioactiveLabel = nil
local trackerPosition = UDim2.new(0, 15, 1, -210)
local trackerVisible = true
local celestialColor = Color3.fromRGB(255, 180, 255)
local radioactiveColor = Color3.fromRGB(120, 255, 120)
local textSize = 22

-- Backpack Info Variables
local backpackInfoParagraph = nil
local backpackRefreshConnection = nil
local backpackSection = nil

-- Remote Detection
local plotUUID = nil
local remoteEvent = nil
local lastAction = ""
local lastUUID = ""
local lastSlot = ""

-- Teleport
local selectedBrainrootType = "Common"
local selectedBrainrootIncome = ""
local brainrootTypes = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythical", "Secret", "Cosmic", "Celestial"}
local brainrootNames = {}
local brainrootIncomeList = {}
local teleportMode = "Tween"

-- Floor positions
local floorPositions = {
    {name = "Home / Spawn", cf = CFrame.new(121, 3, 39)},
    {name = "Common Floor", cf = CFrame.new(199, -3, -1)},
    {name = "Uncommon Floor", cf = CFrame.new(284, -3, -5)},
    {name = "Rare Floor", cf = CFrame.new(397, -3, 3)},
    {name = "Epic Floor", cf = CFrame.new(540, -3, -2)},
    {name = "Legendary Floor", cf = CFrame.new(757, -3, 1)},
    {name = "Mythical Floor", cf = CFrame.new(1072,-3, -6)},
    {name = "Cosmic Floor", cf = CFrame.new(1572,-3, 7)},
    {name = "Secret Floor", cf = CFrame.new(2254,-3, 8)},
    {name = "Celestial Floor", cf = CFrame.new(2633,-3, 12)},
}
local currentFloorIndex = 1
local floorStatus = nil

-- Initialize selected slots
for i = 1, 30 do
    table.insert(selectedSlots, tostring(i))
end

for i = 1, 30 do
    table.insert(selectedUpgradeSlots, tostring(i))
end

-- Find remote function
local function findPlotRemote()
    local success, remote = pcall(function()
        return RS.Packages.Net["RF/Plot.PlotAction"]
    end)
    
    if success and remote then
        remoteEvent = remote
        return true
    end
    return false
end

-- UUID capture hook
local old
old = hookmetamethod(game, "__namecall", function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    if method == "InvokeServer" and self == remoteEvent then
        if args[1] == "Collect Money" then
            if typeof(args[2]) == "string" and #args[2] > 10 then
                if plotUUID ~= args[2] then
                    plotUUID = args[2]
                    lastAction = args[1]
                    lastUUID = args[2]
                    lastSlot = args[3] and tostring(args[3]) or "?"
                end
            end
        end
    end

    return old(self, ...)
end)

-- Helper function to extract income from brainroot
local function getBrainrootIncome(brainroot)
    for _, child in ipairs(brainroot:GetDescendants()) do
        if child:IsA("TextLabel") and child.Text:find("%$") then
            local amount = child.Text:match("%$(.+)%/s")
            if amount then 
                return amount
            end
        end
    end
    return "0"
end

local function getBrainrootMutation(brainroot)
    local handle = brainroot:FindFirstChild("Handle")
    if handle then
        local statsGui = handle:FindFirstChild("StatsGui")
        if statsGui then
            local frame = statsGui:FindFirstChild("Frame")
            if frame then
                local mutationLabel = frame:FindFirstChild("Mutation")
                if mutationLabel and mutationLabel:IsA("TextLabel") and mutationLabel.Text ~= "" then
                    return mutationLabel.Text
                end
            end
        end
    end
    
    for _, child in ipairs(brainroot:GetDescendants()) do
        if child:IsA("TextLabel") then
            local text = child.Text:lower()
            if text:find("mutation") or text:find("mut") and child.Text ~= "" then
                return child.Text
            end
        end
    end
    
    return "No Mutation"
end

local function getBrainrootName(brainroot)
    local rendered = brainroot:FindFirstChild("RenderedBrainrot")
    if rendered then
        for _, child in ipairs(rendered:GetChildren()) do
            if child:IsA("Model") and child.Name ~= "Root" then
                return child.Name
            end
        end
    end
    
    if brainroot.Name and brainroot.Name ~= "Model" then
        return brainroot.Name
    end
    
    for _, child in ipairs(brainroot:GetDescendants()) do
        if child:IsA("TextLabel") and child.Name:lower():find("name") and child.Text ~= "" then
            return child.Text
        end
    end
    
    return "Unknown"
end

local function updateBrainrootNames()
    brainrootNames = {}
    brainrootIncomeList = {}
    for _, brainType in ipairs(brainrootTypes) do
        brainrootNames[brainType] = {}
        brainrootIncomeList[brainType] = {}
        local brainroots = Workspace:FindFirstChild("ActiveBrainrots")
        if brainroots then
            local brainTypeFolder = brainroots:FindFirstChild(brainType)
            if brainTypeFolder then
                for _, brainroot in pairs(brainTypeFolder:GetChildren()) do
                    if brainroot:IsA("Model") then
                        local income = getBrainrootIncome(brainroot)
                        local incomeString = "$" .. income .. "/s"
                        
                        table.insert(brainrootNames[brainType], incomeString)
                        table.insert(brainrootIncomeList[brainType], income)
                    end
                end
            end
        end
    end
end

-- Helper functions
local function GetHRP()
    local char = player.Character
    if char then return char:FindFirstChild("HumanoidRootPart") end
end

local function GetHum()
    return player.Character and player.Character:FindFirstChildOfClass("Humanoid")
end

local function TweenTP(pos)
    local hrp = GetHRP()
    local hum = GetHum()
    if not hrp or not hum then return false end
  
    hum:ChangeState(Enum.HumanoidStateType.PlatformStanding)
  
    local time = 1.0
    local targetCFrame = CFrame.new(pos)
  
    local tween = TweenService:Create(hrp, TweenInfo.new(time, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {CFrame = targetCFrame})
    tween:Play()
    tween.Completed:Wait()
  
    hum:ChangeState(Enum.HumanoidStateType.PlatformStanding)
  
    return true
end

local function InstantTP(pos)
    local hrp = GetHRP()
    if hrp then 
        hrp.CFrame = CFrame.new(pos)
        return true
    end
    
    return false
end

local function TeleportTo(pos)
    if teleportMode == "Tween" then
        return TweenTP(pos)
    else
        return InstantTP(pos)
    end
end

-- ===================== MODIFIED TELEPORT TO BRAINROOT =====================
local function teleportToBrainroot(brainType, income)
    local brainroots = Workspace:FindFirstChild("ActiveBrainrots")
    if not brainroots then return false end
    
    local folder = brainroots:FindFirstChild(brainType)
    if folder then
        for _, brain in pairs(folder:GetChildren()) do
            if brain:IsA("Model") then
                local brainIncome = getBrainrootIncome(brain)
                if brainIncome == income then
                    -- Instead of just teleporting, call the full collection routine
                    -- We don't need a statusParagraph here, so we pass nil
                    return collectBrainroot(brain, nil)
                end
            end
        end
    end
    
    return false
end

local function setupInstantTake()
    if instantTakeEnabled then
        loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Instant-Proximity-Prompt-Script-Roblox-86661"))()
    end
end

-- Radioactive Coins Collection Functions
local function addCoin(coin)
    if coin and coin:IsA("BasePart") and not table.find(coins, coin) then
        coin.Anchored = true
        coin.CanCollide = true
        table.insert(coins, coin)
    end
end

local function initializeCoins()
    coins = {}
    local coinsFolder = Workspace:WaitForChild("EventParts", 5)
    if coinsFolder then
        for _, partFolder in pairs(coinsFolder:GetChildren()) do
            local coin = partFolder:FindFirstChild("Radioactive Coin")
            if coin then
                addCoin(coin)
            end
        end
        
        if not coinCollectionConnection then
            coinCollectionConnection = coinsFolder.ChildAdded:Connect(function(partFolder)
                local coin = partFolder:WaitForChild("Radioactive Coin", 5)
                if coin then
                    addCoin(coin)
                end
            end)
        end
    end
end

local function stopCoinCollection()
    if coinCollectionConnection then
        coinCollectionConnection:Disconnect()
        coinCollectionConnection = nil
    end
    
    for _, coin in pairs(coins) do
        if coin and coin.Parent then
            coin.Anchored = false
            coin.CanCollide = true
        end
    end
    coins = {}
end

local function updateCoinPositions()
    if not collectRadioactiveCoinsEnabled then return end
    
    local character = player.Character
    if character then
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local maxCoins = math.min(coinCylinderSize, #coins)
            for i = 1, maxCoins do
                local coin = coins[i]
                if coin and coin.Parent then
                    local angle = (i / maxCoins) * 2 * math.pi
                    local radius = coinRadius
                    local height = coinHeight
                    local offset = Vector3.new(math.cos(angle) * radius, height, math.sin(angle) * radius)
                    coin.CFrame = hrp.CFrame + offset
                end
            end
        end
    end
end

local function startCoinCollectionLoop()
    task.spawn(function()
        while collectRadioactiveCoinsEnabled do
            if collectRadioactiveCoinsEnabled then
                updateCoinPositions()
            end
            task.wait()
        end
    end)
end

-- Auto Farm Functions
local function collectMoney(slot)
    if plotUUID and remoteEvent then
        local success, err = pcall(function()
            remoteEvent:InvokeServer("Collect Money", plotUUID, tostring(slot))
        end)
    end
end

local function startCollectMoneyLoop()
    task.spawn(function()
        while collectMoneyEnabled do
            if plotUUID then
                for i = 1, 30, moneyCylinderSize do
                    if not collectMoneyEnabled then break end
                    
                    for j = i, math.min(i + moneyCylinderSize - 1, 30) do
                        task.spawn(function()
                            collectMoney(j)
                        end)
                    end
                    
                    task.wait(0.05)
                end
            end
            task.wait(0.1)
        end
    end)
end

local function upgradeBrainroot(slot)
    if plotUUID and remoteEvent then
        local success, err = pcall(function()
            remoteEvent:InvokeServer("Upgrade Brainrot", plotUUID, tostring(slot))
        end)
        return success
    end
    return false
end

local function startUpgradeBrainrootLoop()
    task.spawn(function()
        while upgradeBrainrotEnabled do
            if plotUUID then
                for i = 1, #selectedUpgradeSlots, upgradeCylinderSize do
                    if not upgradeBrainrotEnabled then break end
                    
                    for j = i, math.min(i + upgradeCylinderSize - 1, #selectedUpgradeSlots) do
                        if selectedUpgradeSlots[j] then
                            task.spawn(function()
                                upgradeBrainroot(selectedUpgradeSlots[j])
                            end)
                        end
                    end
                    
                    task.wait(0.1)
                end
            end
            task.wait(0.5)
        end
    end)
end

local function upgradeSpeed(value) 
    local success = pcall(function()
        RS.RemoteFunctions.UpgradeSpeed:InvokeServer(tonumber(value))
    end)
    
    if not success then
        WindUI:Notify({
            Title = "Error",
            Content = "Failed to upgrade speed value " .. value,
            Duration = 2
        })
    end
end

local function startUpgradeSpeedLoop()
    task.spawn(function()
        while upgradeSpeedEnabled do
            local tasks = {}
            for _, v in selectedSpeedValues do 
                if not upgradeSpeedEnabled then break end
                local taskInstance = task.spawn(function()
                    upgradeSpeed(v)
                end)
                table.insert(tasks, taskInstance)
                task.wait(0.002)
            end
            
            for _, taskInstance in pairs(tasks) do
                task.wait()
            end
            
            task.wait(0.1)
        end
    end)
end

local function rebirth() 
    local success = pcall(function()
        RS.RemoteFunctions.Rebirth:InvokeServer()
    end)
    
    if not success then
        WindUI:Notify({
            Title = "Error",
            Content = "Failed to rebirth",
            Duration = 2
        })
    end
end

local function startRebirthLoop()
    task.spawn(function()
        while rebirthEnabled do 
            rebirth()
            task.wait(1.5)
        end
    end)
end

local function upgradeCarry() 
    local success = pcall(function()
        RS.RemoteFunctions.UpgradeCarry:InvokeServer()
    end)
    
    if not success then
        WindUI:Notify({
            Title = "Error",
            Content = "Failed to upgrade carry",
            Duration = 2
        })
    end
end

local function startCarryUpgradeLoop()
    task.spawn(function()
        while carryUpgradeEnabled do 
            upgradeCarry()
            task.wait(1)
        end
    end)
end

local function sellBrainroot() 
    RS.RemoteFunctions.SellTool:InvokeServer() 
end

local function startSellBrainrootLoop()
    task.spawn(function()
        while sellBrainrootEnabled do 
            sellBrainroot()
            task.wait(0.2)
        end
    end)
end

local function sellAll() 
    RS.RemoteFunctions.SellAll:InvokeServer() 
end

local function startSellAllLoop()
    task.spawn(function()
        while sellAllEnabled do 
            sellAll()
            task.wait(1)
        end
    end)
end

local function checkPrice() 
    return RS.RemoteFunctions.GetSellAmount:InvokeServer() 
end

local function upgradeBase() 
    local success = pcall(function()
        RS.RemoteFunctions.UpgradeBase:InvokeServer()
    end)
    
    if not success then
        WindUI:Notify({
            Title = "Error",
            Content = "Failed to upgrade base",
            Duration = 2
        })
    end
end

local function startUpgradeBaseLoop()
    task.spawn(function()
        while upgradeBaseEnabled do 
            upgradeBase()
            task.wait(1.5)
        end
    end)
end

-- Auto Spin Wheel Function
local function spinWheel()
    local success = pcall(function()
        RS.Packages.Net["RF/WheelSpin.Roll"]:InvokeServer()
    end)
    
    if not success then
        WindUI:Notify({
            Title = "Error",
            Content = "Failed to spin wheel",
            Duration = 2
        })
    end
end

local function startAutoSpinLoop()
    task.spawn(function()
        while autoSpinEnabled do 
            spinWheel()
            task.wait(spinCooldown)
        end
    end)
end

-- Hitbox Functions
local function createHitbox(player)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    
    local hrp = player.Character.HumanoidRootPart
    local character = player.Character
    
    local hitboxPart = Instance.new("Part")
    hitboxPart.Name = "CustomHitbox"
    hitboxPart.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
    hitboxPart.Transparency = hitboxTransparency
    hitboxPart.Color = hitboxColor
    hitboxPart.Material = "Neon"
    hitboxPart.CanCollide = false
    hitboxPart.Anchored = false
    hitboxPart.Massless = true
    
    local weld = Instance.new("WeldConstraint")
    weld.Part0 = hrp
    weld.Part1 = hitboxPart
    weld.Parent = hitboxPart
    
    hitboxPart.CFrame = hrp.CFrame
    hitboxPart.Parent = character
    
    hitboxParts[player.UserId] = hitboxPart
    
    return hitboxPart
end

local function updateHitboxes()
    for userId, part in pairs(hitboxParts) do
        local player = Players:GetPlayerByUserId(userId)
        if not player or not player.Character then
            if part and part.Parent then
                part:Destroy()
            end
            hitboxParts[userId] = nil
        end
    end
    
    if not hitboxEnabled then return end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if not hitboxParts[player.UserId] then
                createHitbox(player)
            else
                local hitbox = hitboxParts[player.UserId]
                if hitbox and hitbox.Parent then
                    hitbox.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                    hitbox.Transparency = hitboxTransparency
                    hitbox.Color = hitboxColor
                else
                    createHitbox(player)
                end
            end
        end
    end
end

local function startHitboxLoop()
    task.spawn(function()
        while hitboxEnabled do
            updateHitboxes()
            task.wait(0.1)
        end
    end)
end

local function clearHitboxes()
    for userId, part in pairs(hitboxParts) do
        if part and part.Parent then
            part:Destroy()
        end
    end
    hitboxParts = {}
end

-- Anti-Ragdoll Functions
local function enableAntiRagdoll()
    if not player.Character or not player.Character:FindFirstChildOfClass("Humanoid") then return end
    
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    
    humanoidStateConn = humanoid.StateChanged:Connect(function(oldState, newState)
        if antiRagdollEnabled and newState == Enum.HumanoidStateType.Ragdoll then
            humanoid:ChangeState(Enum.HumanoidStateType.Running)
        end
    end)
end

local function disableAntiRagdoll()
    if humanoidStateConn then
        humanoidStateConn:Disconnect()
        humanoidStateConn = nil
    end
end

-- Extra Life Functions
local extraLifeEnabled = false
local extraLifeConnection = nil

local function applyAntiDie(character)
    if extraLifeConnection then
        extraLifeConnection:Disconnect()
        extraLifeConnection = nil
    end

    local humanoid = character:WaitForChild("Humanoid")

    humanoid.BreakJointsOnDeath = false
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)

    extraLifeConnection = RunService.Heartbeat:Connect(function()
        if humanoid.Health <= 0 then
            humanoid.Health = humanoid.MaxHealth
            humanoid:ChangeState(Enum.HumanoidStateType.Running)
        end
    end)
end

local function toggleExtraLife(state)
    extraLifeEnabled = state
    
    if state then
        if player.Character then
            applyAntiDie(player.Character)
        end
        
        player.CharacterAdded:Connect(applyAntiDie)
        
        WindUI:Notify({
            Title = "Extra Life",
            Content = "Extra life enabled! You will not die.",
            Duration = 3
        })
    else
        if extraLifeConnection then
            extraLifeConnection:Disconnect()
            extraLifeConnection = nil
        end
        
        if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            humanoid.BreakJointsOnDeath = true
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, true)
        end
        
        WindUI:Notify({
            Title = "Extra Life",
            Content = "Extra life disabled!",
            Duration = 3
        })
    end
end

-- Server Management Functions
local function getServerId()
    local jobId = game.JobId
    return jobId
end

local function copyServerId()
    local jobId = getServerId()
    setclipboard(jobId)
    WindUI:Notify({
        Title = "Server ID",
        Content = "Server ID copied to clipboard!",
        Duration = 2
    })
end

local function joinServer(jobId)
    if jobId and jobId ~= "" then
        TeleportService:TeleportToPlaceInstance(game.PlaceId, jobId)
        WindUI:Notify({
            Title = "Server Join",
            Content = "Attempting to join server...",
            Duration = 2
        })
    else
        WindUI:Notify({
            Title = "Error",
            Content = "Invalid server ID",
            Duration = 2
        })
    end
end

local function rejoinServer()
    TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId)
    WindUI:Notify({
        Title = "Rejoin",
        Content = "Rejoining server...",
        Duration = 2
    })
end

local function serverHop()
    local servers = {}
    local req = httprequest or http_request or (syn and syn.request) or request
    if not req then
        WindUI:Notify({
            Title = "Error",
            Content = "HTTP request not supported",
            Duration = 2
        })
        return
    end
    
    local pageToken = ""
    repeat
        local url = string.format("https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=Desc&limit=100&cursor=%s", game.PlaceId, pageToken)
        local response = req({Url = url, Method = "GET"})
        local data = HttpService:JSONDecode(response.Body)
        
        for _, server in pairs(data.data) do
            if server.playing < server.maxPlayers and server.id ~= game.JobId then
                table.insert(servers, server.id)
            end
        end
        
        pageToken = data.nextPageCursor
    until not pageToken or #servers >= 10
    
    if #servers > 0 then
        local randomServer = servers[math.random(1, #servers)]
        TeleportService:TeleportToPlaceInstance(game.PlaceId, randomServer)
        WindUI:Notify({
            Title = "Server Hop",
            Content = "Hopping to a new server...",
            Duration = 2
        })
    else
        WindUI:Notify({
            Title = "Server Hop",
            Content = "No available servers found",
            Duration = 2
        })
    end
end

local function serverHopLowerPlayer()
    local servers = {}
    local req = httprequest or http_request or (syn and syn.request) or request
    if not req then
        WindUI:Notify({
            Title = "Error",
            Content = "HTTP request not supported",
            Duration = 2
        })
        return
    end
    
    local pageToken = ""
    local lowestPlayerCount = math.huge
    local bestServer = nil
    
    repeat
        local url = string.format("https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=Asc&limit=100&cursor=%s", game.PlaceId, pageToken)
        local response = req({Url = url, Method = "GET"})
        local data = HttpService:JSONDecode(response.Body)
        
        for _, server in pairs(data.data) do
            if server.playing < server.maxPlayers and server.id ~= game.JobId and server.playing < lowestPlayerCount then
                lowestPlayerCount = server.playing
                bestServer = server.id
            end
        end
        
        pageToken = data.nextPageCursor
    until not pageToken or bestServer
    
    if bestServer then
        TeleportService:TeleportToPlaceInstance(game.PlaceId, bestServer)
        WindUI:Notify({
            Title = "Server Hop",
            Content = "Hopping to server with " .. lowestPlayerCount .. " players...",
            Duration = 2
        })
    else
        WindUI:Notify({
            Title = "Server Hop",
            Content = "No available servers found",
            Duration = 2
        })
    end
end

-- Event Tracker Functions
local function scanForLabels()
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("SurfaceGui") then
            local frame = obj:FindFirstChild("Frame")
            if frame then
                local t1 = frame:FindFirstChild("TextLabel")
                local t2 = frame:FindFirstChild("TextLabel2")
                if t1 and t2 then
                    celestialLabel = t1
                    radioactiveLabel = t2
                    return true
                end
            end
        end
    end
    return false
end

local function createEventTrackerGui()
    if eventTrackerGui then
        eventTrackerGui:Destroy()
    end

    eventTrackerGui = Instance.new("ScreenGui")
    eventTrackerGui.Name = "EventTrackerHUD"
    eventTrackerGui.ResetOnSpawn = false
    eventTrackerGui.Parent = player:WaitForChild("PlayerGui")

    local celestialShadow = Instance.new("TextLabel")
    celestialShadow.Size = UDim2.new(0, 320, 0, 24)
    celestialShadow.Position = trackerPosition + UDim2.new(0, 2, 0, 2)
    celestialShadow.BackgroundTransparency = 1
    celestialShadow.TextXAlignment = Enum.TextXAlignment.Left
    celestialShadow.Font = Enum.Font.GothamBold
    celestialShadow.TextSize = textSize
    celestialShadow.TextColor3 = Color3.new(0, 0, 0)
    celestialShadow.TextStrokeTransparency = 1
    celestialShadow.Text = "CELESTIAL: --:--"
    celestialShadow.Visible = trackerVisible
    celestialShadow.Parent = eventTrackerGui

    local celestialText = Instance.new("TextLabel")
    celestialText.Size = UDim2.new(0, 320, 0, 24)
    celestialText.Position = trackerPosition
    celestialText.BackgroundTransparency = 1
    celestialText.TextXAlignment = Enum.TextXAlignment.Left
    celestialText.Font = Enum.Font.GothamBold
    celestialText.TextSize = textSize
    celestialText.TextColor3 = celestialColor
    celestialText.TextStrokeColor3 = Color3.new(0,0,0)
    celestialText.TextStrokeTransparency = 0
    celestialText.Text = "CELESTIAL: --:--"
    celestialText.Visible = trackerVisible
    celestialText.Parent = eventTrackerGui

    local radioactiveShadow = Instance.new("TextLabel")
    radioactiveShadow.Size = UDim2.new(0, 320, 0, 24)
    radioactiveShadow.Position = UDim2.new(trackerPosition.X.Scale, trackerPosition.X.Offset, trackerPosition.Y.Scale, trackerPosition.Y.Offset + 28) + UDim2.new(0, 2, 0, 2)
    radioactiveShadow.BackgroundTransparency = 1
    radioactiveShadow.TextXAlignment = Enum.TextXAlignment.Left
    radioactiveShadow.Font = Enum.Font.GothamBold
    radioactiveShadow.TextSize = textSize
    radioactiveShadow.TextColor3 = Color3.new(0, 0, 0)
    radioactiveShadow.TextStrokeTransparency = 1
    radioactiveShadow.Text = "RADIOACTIVE: --:--"
    radioactiveShadow.Visible = trackerVisible
    radioactiveShadow.Parent = eventTrackerGui

    local radioactiveText = Instance.new("TextLabel")
    radioactiveText.Size = UDim2.new(0, 320, 0, 24)
    radioactiveText.Position = UDim2.new(trackerPosition.X.Scale, trackerPosition.X.Offset, trackerPosition.Y.Scale, trackerPosition.Y.Offset + 28)
    radioactiveText.BackgroundTransparency = 1
    radioactiveText.TextXAlignment = Enum.TextXAlignment.Left
    radioactiveText.Font = Enum.Font.GothamBold
    radioactiveText.TextSize = textSize
    radioactiveText.TextColor3 = radioactiveColor
    radioactiveText.TextStrokeColor3 = Color3.new(0,0,0)
    radioactiveText.TextStrokeTransparency = 0
    radioactiveText.Text = "RADIOACTIVE: --:--"
    radioactiveText.Visible = trackerVisible
    radioactiveText.Parent = eventTrackerGui

    task.spawn(function()
        while eventTrackerEnabled do
            if celestialLabel then
                local txt = celestialLabel.Text:gsub("<[^>]->", "")
                local fullText = "" .. txt
                celestialText.Text = fullText
                celestialShadow.Text = fullText
            end
            if radioactiveLabel then
                local txt = radioactiveLabel.Text:gsub("<[^>]->", "")
                local fullText = "" .. txt
                radioactiveText.Text = fullText
                radioactiveShadow.Text = fullText
            end
            task.wait(0.2)
        end
    end)

    return {
        CelestialText = celestialText,
        RadioactiveText = radioactiveText
    }
end

local function toggleEventTracker(enabled)
    eventTrackerEnabled = enabled
    if enabled then
        scanForLabels()
        createEventTrackerGui()
    else
        if eventTrackerGui then
            eventTrackerGui:Destroy()
            eventTrackerGui = nil
        end
    end
end

-- Backpack Info Functions for Wind UI
local function updateBackpackInfo()
    if not backpackInfoParagraph then return end
    
    local items = {}
    for _, tool in ipairs(player.Backpack:GetChildren()) do
        local rm = tool:FindFirstChild("RenderModel")
        if rm then
            local name = rm:GetAttribute("BrainrotName") or tool.Name
            local mutation = rm:GetAttribute("Mutation") or "None"
            local level = rm:GetAttribute("Level") or 1
            table.insert(items, string.format("%s | %s | Lv.%d", name, mutation, level))
        end
    end
    
    if #items > 0 then
        backpackInfoParagraph:SetDesc(table.concat(items, "\n"))
    else
        backpackInfoParagraph:SetDesc("No brainroots in backpack")
    end
end

local function startBackpackRefresh()
    if backpackRefreshConnection then return end
    
    backpackRefreshConnection = task.spawn(function()
        while true do
            if backpackInfoParagraph then
                updateBackpackInfo()
            end
            task.wait(5)
        end
    end)
end

local function stopBackpackRefresh()
    if backpackRefreshConnection then
        task.cancel(backpackRefreshConnection)
        backpackRefreshConnection = nil
    end
end

local function teleportToFloor(index)
    if index < 1 or index > #floorPositions then return false end
    local targetPos = floorPositions[index].cf.Position + Vector3.new(0, 3, 0)
    local success = TeleportTo(targetPos)
    if success then
        currentFloorIndex = index
        WindUI:Notify({
            Title = "Floor Teleport",
            Content = "Moved to: " .. floorPositions[index].name,
            Duration = 2.5
        })
    end
    return success
end

local function toggleNoclip(state)
    if state then
        if noclipConn then noclipConn:Disconnect() end
        noclipConn = RunService.Stepped:Connect(function()
            if player.Character then
                for _, part in pairs(player.Character:GetDescendants()) do
                    if part:IsA("BasePart") then part.CanCollide = false end
                end
            end
        end)
    else
        if noclipConn then noclipConn:Disconnect() noclipConn = nil end
    end
end

-- Fly System
local function startFly()
    if not GetHRP() or not GetHum() then return end
    local bv = Instance.new("BodyVelocity", GetHRP())
    bv.MaxForce = Vector3.new(9e9,9e9,9e9) bv.Velocity = Vector3.zero
    local bg = Instance.new("BodyGyro", GetHRP())
    bg.MaxTorque = Vector3.new(9e9,9e9,9e9) bg.P = 9e4 bg.CFrame = GetHRP().CFrame

    flyConnection = RunService.Heartbeat:Connect(function()
        if not flyEnabled or not flying then
            bv:Destroy() bg:Destroy()
            if flyConnection then flyConnection:Disconnect() flyConnection = nil end
            return
        end
        local moveDir = GetHum().MoveDirection
        local upDown = (UserInputService:IsKeyDown(Enum.KeyCode.Space) and 1) or (UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) and -1) or 0
        bv.Velocity = (moveDir * speed) + Vector3.new(0, upDown * speed, 0)
        bg.CFrame = GetHRP().CFrame
    end)
end

local function stopFly()
    flying = false
    if flyConnection then flyConnection:Disconnect() flyConnection = nil end
    if GetHRP() then
        for _, obj in pairs(GetHRP():GetChildren()) do
            if obj:IsA("BodyVelocity") or obj:IsA("BodyGyro") then obj:Destroy() end
        end
    end
end

-- === COLOR SYSTEM ===
local rarityColors = {
    ["Common"] = Color3.fromRGB(0, 255, 0),
    ["Uncommon"] = Color3.fromRGB(0, 195, 255),
    ["Rare"] = Color3.fromRGB(0, 100, 255),
    ["Epic"] = Color3.fromRGB(180, 0, 255),
    ["Legendary"] = Color3.fromRGB(255, 215, 0),
    ["Mythical"] = Color3.fromRGB(200, 0, 255),
    ["Secret"] = Color3.fromRGB(255, 105, 180),
    ["Cosmic"] = Color3.fromRGB(0, 255, 255),
    ["Celestial"] = Color3.fromRGB(255, 255, 200),
    ["Print"] = Color3.fromRGB(128, 128, 128)
}

-- === ESP SYSTEM ===
local function calculateDistance(part)
    local hrp = GetHRP()
    if not hrp or not part then return 0 end
    local pos = part.PrimaryPart and part.PrimaryPart.Position or part.Position
    return math.floor((hrp.Position - pos).Magnitude)
end

-- ESP Functions
local function createEspHighlight(part, color)
    local highlight = Instance.new("Highlight")
    highlight.FillColor = color
    highlight.OutlineColor = color
    highlight.FillTransparency = 0.3
    highlight.OutlineTransparency = 0
    highlight.Parent = part
    return highlight
end

local function createEspLabel(part, text, textColor)
    local billboard = Instance.new("BillboardGui")
    billboard.Size = UDim2.new(0, 180, 0, 40)
    billboard.StudsOffset = Vector3.new(0, 2, 0)
    billboard.AlwaysOnTop = true
    billboard.Parent = part

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = textColor
    label.TextStrokeTransparency = 0.5
    label.TextScaled = true
    label.Font = Enum.Font.SourceSansBold
    label.RichText = true
    label.Parent = billboard

    return billboard, label
end

local function cleanupEspObjects()
    for _, obj in pairs(espObjects) do
        if obj and obj.Parent then
            obj:Destroy()
        end
    end
    espObjects = {}
    espLabels = {}
    
    if espUpdateConnection then
        espUpdateConnection:Disconnect()
        espUpdateConnection = nil
    end
end

local function clearEsp()
    cleanupEspObjects()
    
    if espUpdateConnection then
        espUpdateConnection:Disconnect()
        espUpdateConnection = nil
    end
end

-- BRAINROOT INFO EXTRACTION
local function getBrainrootInfo(brainroot)
    local name = "???"
    local moneyPerSec = "??"
    local mutation = "None"
    local mutationColorHex = "CCCCCC"

    name = "???"

    for _, child in ipairs(brainroot:GetDescendants()) do
        if child:IsA("TextLabel") and child.Text:find("%$") then
            local amount = child.Text:match("%$(.+)%/s")
            if amount then 
                moneyPerSec = amount
            end
        end
    end

    local handle = brainroot:FindFirstChild("Handle")
    if handle then
        local statsGui = handle:FindFirstChild("StatsGui")
        if statsGui then
            local frame = statsGui:FindFirstChild("Frame")
            if frame then
                local mutationLabel = frame:FindFirstChild("Mutation")
                if mutationLabel and mutationLabel:IsA("TextLabel") and mutationLabel.Text ~= "" then
                    mutation = mutationLabel.Text
                    local c = mutationLabel.TextColor3
                    mutationColorHex = string.format("%02X%02X%02X",
                        math.clamp(math.floor(c.R * 255), 0, 255),
                        math.clamp(math.floor(c.G * 255), 0, 255),
                        math.clamp(math.floor(c.B * 255), 0, 255)
                    )
                end
            end
        end
    end

    return {
        name = name,
        moneyPerSec = moneyPerSec,
        mutation = mutation,
        mutationColorHex = mutationColorHex
    }
end

-- SETUP BRAINROOT ESP
local function setupBrainrootEsp()
    if not brainrootEspEnabled then return end

    local brainroots = Workspace:FindFirstChild("ActiveBrainrots")
    if not brainroots then return end

    local floorToType = {
        ["Common Floor"] = "Common", ["Uncommon Floor"] = "Uncommon",
        ["Rare Floor"] = "Rare", ["Epic Floor"] = "Epic",
        ["Legendary Floor"] = "Legendary", ["Mythical Floor"] = "Mythical",
        ["Cosmic Floor"] = "Cosmic", ["Secret Floor"] = "Secret",
        ["Celestial Floor"] = "Celestial"
    }

    for _, floorName in ipairs(selectedFloorsForEsp) do
        local brainType = floorToType[floorName]
        if brainType then
            local folder = brainroots:FindFirstChild(brainType)
            if folder then
                for _, brain in pairs(folder:GetChildren()) do
                    if brain:IsA("Model") and brain.Parent then
                        local alreadyExists = false
                        for _, data in ipairs(espLabels) do
                            if data.Type == "Brainroot" and data.BrainType == brainType and data.Part == brain then
                                alreadyExists = true
                                break
                            end
                        end
                        
                        if not alreadyExists then
                            local info = getBrainrootInfo(brain)
                            local baseColor = rarityColors[brainType] or Color3.new(1, 1, 1)
                            local textColor = brainType == "Mythical" and Color3.new(1, 1, 1) or baseColor

                            local highlight = createEspHighlight(brain, baseColor)
                            local billboard, label = createEspLabel(brain, "", textColor)

                            table.insert(espObjects, highlight)
                            table.insert(espObjects, billboard)
                            table.insert(espLabels, {
                                Type = "Brainroot",
                                Part = brain,
                                Label = label,
                                BrainType = brainType,
                                BaseText = info.name,
                                MoneyPerSec = info.moneyPerSec,
                                Mutation = info.mutation,
                                MutationColorHex = info.mutationColorHex
                            })
                        end
                    end
                end
            end
        end
    end
end

local function getAdornee(obj)
    if obj:IsA("BasePart") then
        return obj
    end
    if obj:IsA("Model") then
        if obj.PrimaryPart then
            return obj.PrimaryPart
        end
        for _,v in ipairs(obj:GetDescendants()) do
            if v:IsA("BasePart") then
                return v
            end
        end
    end
    return nil
end

local function getRarity(name)
    for rarity,_ in pairs(luckyBlockColors) do
        if string.find(name, rarity) then
            return rarity
        end
    end
end

local function createLuckyBlockESP(obj)
    if obj:FindFirstChild("LuckyBlockESP") then return end

    local rarity = getRarity(obj.Name)
    if not rarity or not table.find(selectedLuckyBlockRarities, rarity) then return end

    local adornee = getAdornee(obj)
    if not adornee then return end

    local gui = Instance.new("BillboardGui")
    gui.Name = "LuckyBlockESP"
    gui.Adornee = adornee
    gui.Size = UDim2.new(0,220,0,55)
    gui.StudsOffset = Vector3.new(0,3,0)
    gui.AlwaysOnTop = true
    gui.Parent = obj

    local text = Instance.new("TextLabel")
    text.Size = UDim2.fromScale(1,1)
    text.BackgroundTransparency = 1
    text.TextScaled = true
    text.Font = Enum.Font.GothamBold
    text.TextStrokeTransparency = 0
    text.TextStrokeColor3 = Color3.new(0,0,0)
    text.TextColor3 = luckyBlockColors[rarity]
    text.Text = "Lucky Block\n["..rarity.."]"
    text.Parent = gui
    
    local highlight = createEspHighlight(obj, luckyBlockColors[rarity])
    table.insert(espObjects, highlight)
    table.insert(espObjects, gui)
    table.insert(espLabels, {
        Type = "LuckyBlock",
        Part = obj,
        Label = text,
        Rarity = rarity,
        BaseText = "Lucky Block",
        ESPGui = gui
    })
end

local function setupLuckyBlockEsp()
    if not luckyBlockEspEnabled then return end

    local LuckyFolder = Workspace:FindFirstChild("ActiveLuckyBlocks")
    if not LuckyFolder then return end

    for _,obj in ipairs(LuckyFolder:GetChildren()) do
        createLuckyBlockESP(obj)
    end
end

-- UPDATE LOOP
local function updateEspDistances()
    local toRemove = {}
    
    for i, data in ipairs(espLabels) do
        if not data.Part or not data.Part.Parent or not data.Label or not data.Label.Parent then
            table.insert(toRemove, i)
        else
            if data.Type == "Brainroot" then
                local dist = calculateDistance(data.Part)
                
                local mutationTag = ""
                if data.Mutation ~= "None" then
                    mutationTag = "<font color=\"#" .. data.MutationColorHex .. "\">[" .. data.Mutation .. "]</font>"
                end
                
                local moneyTag = "<font color=\"#00FF00\">$" .. data.MoneyPerSec .. "/s</font>"

                local mainText = string.format(
                    "%s - %s %s %s [%dm]",
                    data.BrainType,
                    data.BaseText,
                    moneyTag,
                    mutationTag,
                    dist
                )

                data.Label.Text = mainText
            elseif data.Type == "Player" then
                local dist = calculateDistance(data.Part)
                data.Label.Text = string.format("%s [%dm]", data.Player.Name, dist)
            elseif data.Type == "LuckyBlock" then
                local dist = calculateDistance(data.Part)
                if data.ESPGui then
                    data.Label.Text = "Lucky Block\n["..data.Rarity.."] ["..dist.."m]"
                else
                    data.Label.Text = string.format("%s %s [%dm]", data.Rarity, data.BaseText, dist)
                end
            end
        end
    end
    
    for i = #toRemove, 1, -1 do
        local idx = toRemove[i]
        local obj1Index = (idx * 2) - 1
        local obj2Index = idx * 2
        
        if espObjects[obj1Index] and espObjects[obj1Index].Parent then 
            espObjects[obj1Index]:Destroy() 
        end
        if espObjects[obj2Index] and espObjects[obj2Index].Parent then 
            espObjects[obj2Index]:Destroy() 
        end
        
        table.remove(espObjects, obj2Index)
        table.remove(espObjects, obj1Index)
        table.remove(espLabels, idx)
    end
end

-- UPDATE ESP FUNCTION
local function updateEsp()
    if espUpdateConnection then
        espUpdateConnection:Disconnect()
        espUpdateConnection = nil
    end
    
    clearEsp()
    
    if brainrootEspEnabled then setupBrainrootEsp() end
    if playerEspEnabled then updatePlayerEsp() end
    if luckyBlockEspEnabled then setupLuckyBlockEsp() end
    
    if #espLabels > 0 then
        espUpdateConnection = RunService.Heartbeat:Connect(updateEspDistances)
    end
end

-- MONITORING
local function startEspMonitoring()
    if brainrootMonitorConnection then
        brainrootMonitorConnection:Disconnect()
        brainrootMonitorConnection = nil
    end

    if not brainrootEspEnabled and not luckyBlockEspEnabled then return end

    brainrootMonitorConnection = RunService.Heartbeat:Connect(function()
        local shouldUpdate = false

        if brainrootEspEnabled then
            local brainroots = Workspace:FindFirstChild("ActiveBrainrots")
            if brainroots then
                local existing = {}
                for _, d in ipairs(espLabels) do
                    if d.Type == "Brainroot" then
                        if not existing[d.BrainType] then existing[d.BrainType] = {} end
                        existing[d.BrainType][d.Part] = true
                    end
                end

                local floorToType = {
                    ["Common Floor"] = "Common", ["Uncommon Floor"] = "Uncommon",
                    ["Rare Floor"] = "Rare", ["Epic Floor"] = "Epic",
                    ["Legendary Floor"] = "Legendary", ["Mythical Floor"] = "Mythical",
                    ["Cosmic Floor"] = "Cosmic", ["Secret Floor"] = "Secret",
                    ["Celestial Floor"] = "Celestial"
                }

                for _, floorName in ipairs(selectedFloorsForEsp) do
                    local brainType = floorToType[floorName]
                    if brainType then
                        local folder = brainroots:FindFirstChild(brainType)
                        if folder then
                            for _, brain in pairs(folder:GetChildren()) do
                                if brain:IsA("Model") and brain.Parent then
                                    if not existing[brainType] or not existing[brainType][brain] then
                                        shouldUpdate = true
                                        break
                                    end
                                end
                            end
                            if shouldUpdate then break end
                        end
                    end
                    if shouldUpdate then break end
                end
            end
        end
        
        if luckyBlockEspEnabled and not shouldUpdate then
            local LuckyFolder = Workspace:FindFirstChild("ActiveLuckyBlocks")
            if LuckyFolder then
                local existing = {}
                for _, d in ipairs(espLabels) do
                    if d.Type == "LuckyBlock" then
                        if not existing[d.Rarity] then existing[d.Rarity] = {} end
                        existing[d.Rarity][d.Part] = true
                    end
                end

                for _, obj in ipairs(LuckyFolder:GetChildren()) do
                    local rarity = getRarity(obj.Name)
                    if rarity and table.find(selectedLuckyBlockRarities, rarity) then
                        if not existing[rarity] or not existing[rarity][obj] then
                            shouldUpdate = true
                            break
                        end
                    end
                    if shouldUpdate then break end
                end
            end
        end

        if shouldUpdate then
            updateEsp()
        end
    end)
end

-- PLAYER ESP
local function createPlayerEsp(player)
    if player == player then return end
    
    local character = player.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    local highlight = createEspHighlight(character, Color3.fromRGB(255, 0, 0))
    local billboard, label = createEspLabel(rootPart, player.Name, Color3.fromRGB(255, 255, 255))
    
    table.insert(espObjects, highlight)
    table.insert(espObjects, billboard)
    table.insert(espLabels, {
        Type = "Player",
        Part = character,
        Label = label,
        Player = player
    })
end

local function updatePlayerEsp()
    if not playerEspEnabled then return end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= player then
            local alreadyExists = false
            for _, data in ipairs(espLabels) do
                if data.Type == "Player" and data.Player == player then
                    alreadyExists = true
                    break
                end
            end
            
            if not alreadyExists and player.Character then
                createPlayerEsp(player)
            end
        end
    end
end

local function togglePlayerEsp(state)
    playerEspEnabled = state
    
    if not state then
        local toRemove = {}
        for i, labelData in ipairs(espLabels) do
            if labelData.Type == "Player" then
                table.insert(toRemove, i)
            end
        end
        
        for i = #toRemove, 1, -1 do
            local index = toRemove[i]
            local labelData = espLabels[index]
            
            if espObjects[(index * 2) - 1] and espObjects[(index * 2) - 1].Parent then
                espObjects[(index * 2) - 1]:Destroy()
            end
            if espObjects[index * 2] and espObjects[index * 2].Parent then
                espObjects[index * 2]:Destroy()
            end
            
            table.remove(espLabels, index)
        end
        
        local newEspObjects = {}
        for _, obj in pairs(espObjects) do
            if obj and obj.Parent then
                table.insert(newEspObjects, obj)
            end
        end
        espObjects = newEspObjects
        
        if #espLabels == 0 and espUpdateConnection then
            espUpdateConnection:Disconnect()
            espUpdateConnection = nil
        end
    else
        updatePlayerEsp()
        
        if not espUpdateConnection then
            espUpdateConnection = RunService.Heartbeat:Connect(updateEspDistances)
        end
    end
end

local function toggleLuckyBlockEsp(state)
    luckyBlockEspEnabled = state
    
    if not state then
        local toRemove = {}
        for i, labelData in ipairs(espLabels) do
            if labelData.Type == "LuckyBlock" then
                table.insert(toRemove, i)
            end
        end
        
        for i = #toRemove, 1, -1 do
            local index = toRemove[i]
            local labelData = espLabels[index]
            
            if espObjects[(index * 2) - 1] and espObjects[(index * 2) - 1].Parent then
                espObjects[(index * 2) - 1]:Destroy()
            end
            if espObjects[index * 2] and espObjects[index * 2].Parent then
                espObjects[index * 2]:Destroy()
            end
            
            table.remove(espLabels, index)
        end
        
        local newEspObjects = {}
        for _, obj in pairs(espObjects) do
            if obj and obj.Parent then
                table.insert(newEspObjects, obj)
            end
        end
        espObjects = newEspObjects
        
        if #espLabels == 0 and espUpdateConnection then
            espUpdateConnection:Disconnect()
            espUpdateConnection = nil
        end
    else
        setupLuckyBlockEsp()
        
        if not espUpdateConnection then
            espUpdateConnection = RunService.Heartbeat:Connect(updateEspDistances)
        end
    end
end

local function setupPlayerEspRespawnHandling()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= player then
            player.CharacterAdded:Connect(function()
                if playerEspEnabled then
                    task.wait(0.5)
                    updatePlayerEsp()
                end
            end)
        end
    end
    
    Players.PlayerAdded:Connect(function(player)
        if playerEspEnabled then
            player.CharacterAdded:Connect(function()
                task.wait(0.5)
                updatePlayerEsp()
            end)
        end
    end)
end

local function toggleBrainrootEsp(state)
    brainrootEspEnabled = state
    if state then
        updateEsp()
        startEspMonitoring()
    else
        if brainrootMonitorConnection then
            brainrootMonitorConnection:Disconnect()
            brainrootMonitorConnection = nil
        end
        local toRemove = {}
        for i, labelData in ipairs(espLabels) do
            if labelData.Type == "Brainroot" then
                table.insert(toRemove, i)
            end
        end
        for i = #toRemove, 1, -1 do
            local index = toRemove[i]
            if espLabels[index].Label and espLabels[index].Label.Parent then
                espLabels[index].Label:Destroy()
            end
            table.remove(espLabels, index)
        end
        updateEsp()
    end
end

local function onLuckyBlockAdded(obj)
    if luckyBlockEspEnabled then
        task.wait(0.2)
        createLuckyBlockESP(obj)
    end
end

local function setupLuckyBlockAutoDetect()
    local LuckyFolder = Workspace:FindFirstChild("ActiveLuckyBlocks")
    if not LuckyFolder then return end
    
    -- Disconnect existing connection if any
    if luckyBlockAddedConnection then
        luckyBlockAddedConnection:Disconnect()
        luckyBlockAddedConnection = nil
    end
    
    -- Create new connection
    luckyBlockAddedConnection = LuckyFolder.ChildAdded:Connect(onLuckyBlockAdded)
end

-- Tambahkan variabel untuk connection di bagian atas
local luckyBlockAddedConnection = nil


-- 
--                                 UI PART
-- 

task.spawn(function()
    if not WindUI or not WindUI.CreateWindow then return end
    task.wait(1)
    updateBrainrootNames()
    findPlotRemote()
    
    -- Theme
    WindUI:AddTheme({
        Name = "Tsunami Theme",
        Accent = Color3.fromRGB(76, 175, 80),
        Dialog = Color3.fromRGB(22, 22, 22),
        Outline = Color3.fromRGB(255, 255, 255),
        Text = Color3.fromRGB(255, 255, 255),
        Placeholder = Color3.fromRGB(122, 122, 122),
        Background = Color3.fromRGB(30, 78, 45),
        Button = Color3.fromRGB(56, 142, 60),
        Icon = Color3.fromRGB(255, 255, 255)
    })
    
    local Window = WindUI:CreateWindow({
        Title = "Cyraa Hub",
        SubTitle = "v1.0.5",
        Folder = "CyraaHub Config",
        Icon = "rbxthumb://type=Asset&id=106624117427771&w=150&h=150",
        NewElements = true,
        Color = Color3.fromRGB(255, 105, 180),
        OpenButton = {
            Title = "by komtolmmek2 script",
            Icon = "rbxthumb://type=Asset&id=106624117427771&w=150&h=150",
            CornerRadius = UDim.new(1,0),
            StrokeThickness = 3,
            Enabled = true,
            Draggable = true,
            OnlyMobile = false,
            Color = ColorSequence.new(
                Color3.fromRGB(48, 255, 106),
                Color3.fromRGB(231, 255, 47)
            ),
            BackgroundColor = Color3.fromRGB(0, 0, 0),
            TextColor = Color3.fromRGB(255, 105, 180),
        },
        Topbar = {
            Height = 44,
            ButtonsType = "Mac",
            Color = Color3.fromRGB(0, 0, 0)
        },
        Size = UDim2.fromOffset(560, 350),
        MinSize = Vector2.new(560, 350),
        MaxSize = Vector2.new(850, 560),
        Transparent = true,
        Theme = "Tsunami Theme",
        Resizable = true,
        SideBarWidth = 200,
        BackgroundImageTransparency = 0.42,
        ScrollBarEnabled = false
    })
        Window:Tag({
        Title = "v1.0.5",
        Icon = "github",
        Color = Color3.fromRGB(255, 255, 255),
        Border = true,
    })
    
    Window:Tag({
        Title = "Escape Tsunami For Brainrots!",
        Icon = "rbxthumb://type=Asset&id=106624117427771&w=150&h=150",
        Color = Color3.fromRGB(30, 78, 45),
        Border = true,
    })

    --===[ HOME TAB ]===--
    local homeTab = Window:Tab({ Title = "Home", Icon = "solar:home-2-bold", Color = Color3.fromRGB(255, 105, 180) })
    
    homeTab:Section({ Title = "Update Log" })
    homeTab:Paragraph({ 
        Title = "Version 1.0.5", 
        Desc = "Home Tab\n   [+] Check Backpack[alwasy refresh every 5 sec]\n\nAuto Farm Tab\n    [+] Auto Farm Brainroot (Beta)\n    [+] Auto Farm Lucky Block (Home Return)\n\nESP Tab\n    [/] Fix Esp bug\n    [+] Lucky Block ESP\n\nTeleport Tab\n    [+] Auto Gap (Beta)\n\nSetting Tab\n    [+] Extra Life",
        Image = "solar:document-text-bold",
        ImageSize = 20
    })
    
    homeTab:Section({ Title = "Game Information" })
    
    local GameTimeParagraph = homeTab:Paragraph({
        Title = "Game Time",
        Desc = "0",
        Image = "timer",
        ImageSize = 20
    });
    
    spawn(function()
        while task.wait() do
            pcall(function()
                local GameTime = math.floor(workspace.DistributedGameTime + 0.5);
                local Hour = math.floor(GameTime / 60 ^ 2) % 24;
                local Minute = math.floor(GameTime / 60 ^ 1) % 60;
                local Second = math.floor(GameTime / 60 ^ 0) % 60;
                GameTimeParagraph:SetDesc(Hour .. " Hours " .. Minute .. " Minute " .. Second .. " Second");
            end);
        end
    end);
    
    local FpsParagraph = homeTab:Paragraph({
        Title = "Fps",
        Desc = "0",
        Image = "monitor",
        ImageSize = 20
    });
    
    spawn(function()
        while task.wait() do
            pcall(function()
                FpsParagraph:SetDesc(math.floor(workspace:GetRealPhysicsFPS()) .. " FPS");
            end);
        end
    end);
    
    local PingParagraph = homeTab:Paragraph({
        Title = "Ping",
        Desc = "0",
        Image = "signal",
        ImageSize = 20
    });
    
    spawn(function()
        while task.wait() do
            pcall(function()
                PingParagraph:SetDesc((game:GetService("Stats")).Network.ServerStatsItem["Data Ping"]:GetValueString());
            end);
        end
    end);
    
    backpackSection = homeTab:Section({ 
        Title = "Backpack Information",
        Collapsed = false
    })
    
    backpackInfoParagraph = backpackSection:Paragraph({
        Title = "Brainroot Backpack",
        Desc = "Loading backpack items...",
        Image = "backpack",
        ImageSize = 20
    })
    
    local searchInput = backpackSection:Input({
        Title = "Search Backpack",
        Desc = "Search for specific brainroots",
        Placeholder = "Enter brainroot name...",
        Callback = function(text)
            if not text or text == "" then
                updateBackpackInfo()
                return
            end
            
            local items = {}
            text = text:lower()
            for _, tool in ipairs(player.Backpack:GetChildren()) do
                local rm = tool:FindFirstChild("RenderModel")
                if rm then
                    local name = rm:GetAttribute("BrainrotName") or tool.Name
                    local mutation = rm:GetAttribute("Mutation") or "None"
                    local level = rm:GetAttribute("Level") or 1
                    
                    if name:lower():find(text) or mutation:lower():find(text) then
                        table.insert(items, string.format("%s | %s | Lv.%d", name, mutation, level))
                    end
                end
            end
            
            if #items > 0 then
                backpackInfoParagraph:SetDesc(table.concat(items, "\n"))
            else
                backpackInfoParagraph:SetDesc("No matching brainroots found")
            end
        end
    })
    
    startBackpackRefresh()
    
    homeTab:Section({ Title = "Plot Status" })
    
    local remoteStatusParagraph = homeTab:Paragraph({
        Title = "Collect Money Status",
        Desc = "Waiting for player Collect money...",
        Image = "radar",
        ImageSize = 20
    });
    
    local uuidDisplay = homeTab:Paragraph({
        Title = "Current Plot",
        Desc = "Not detected yet",
        Image = "key",
        ImageSize = 20
    })
    
    local lastActionDisplay = homeTab:Paragraph({
        Title = "Last Detected Action",
        Desc = "None",
        Image = "activity",
        ImageSize = 20
    })
    
    spawn(function()
        while task.wait() do
            pcall(function()
                if plotUUID then
                    remoteStatusParagraph:SetDesc(" Collect Money automatically detected!")
                    uuidDisplay:SetDesc(plotUUID)
                    lastActionDisplay:SetDesc(lastAction .. " (Slot: " .. lastSlot .. ")")
                else
                    remoteStatusParagraph:SetDesc(" Collect Money not detected yet")
                    uuidDisplay:SetDesc("Not detected yet")
                    lastActionDisplay:SetDesc("None")
                end
            end);
        end
    end)
    
    homeTab:Section({ Title = "Social Links" })
    
    local DiscordServerParagraph = homeTab:Paragraph({
        Title = "Discord Server",
        Desc = "Join our Discord server!",
        TextXAlignment = "Left",
        Buttons = {{
            Title = "Copy Link",
            Callback = function()
                setclipboard("https://discord.gg/BMrXHt4rJv")
                WindUI:Notify({
                    Title = "Notification",
                    Content = "Discord link copied!",
                    Icon = "bell",
                    Duration = 3
                })
            end
        }}
    })

    local DiscordServerParagraph1 = homeTab:Paragraph({
        Title = "Social Media",
        Desc = "Follow our social media!",
        TextXAlignment = "Left",
        Buttons = {{
            Title = "Copy Link",
            Callback = function()
                setclipboard("https://www.tiktok.com/@komtolmmek2")
                WindUI:Notify({
                    Title = "Notification",
                    Content = "Social link copied!",
                    Icon = "bell",
                    Duration = 3
                })
            end
        }}
    })

    -- AUTO FARM TAB
    local AutoFarmTab = Window:Tab({Title = "Auto Farm", Icon = "solar:cpu-bold", Color = Color3.fromRGB(255, 105, 180)})
   
    AutoFarmTab:Section({Title = "Auto Farm Brainroot"})
    local autoFarmBrainrootStatus = AutoFarmTab:Paragraph({
        Title = "Status",
        Desc = "Idle",
        Image = "activity",
        ImageSize = 20
    })

    AutoFarmTab:Dropdown({
        Title = "Select Rarity",
        Desc = "Choose the rarity of brainroot to farm",
        Values = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythical", "Cosmic", "Secret", "Celestial"},
        Value = "Common",
        Callback = function(v)
            selectedRarity = v
        end
    })

    AutoFarmTab:Toggle({
        Title = "Auto Farm Brainroot (Beta)",
        Desc = "Automatically farm the selected rarity brainroot",
        Callback = function(v)
            autoFarmBrainrootEnabled = v
            if v then
                task.spawn(function()
                    while autoFarmBrainrootEnabled do
                        local success = autoFarmBrainroot(selectedRarity, autoFarmBrainrootStatus)
                        if success then
                            task.wait(5) -- Wait 5 seconds before trying again
                        else
                            task.wait(10) -- Wait longer if failed
                        end
                    end
                    if autoFarmBrainrootStatus then autoFarmBrainrootStatus:SetDesc("Stopped") end
                end)
            else
                if autoFarmBrainrootStatus then autoFarmBrainrootStatus:SetDesc("Stopped") end
            end
        end
    })
   
    AutoFarmTab:Section({Title = "Money Collection"})
    AutoFarmTab:Toggle({
        Title = "Auto Collect Money",
        Desc = "Automatically collect money all slot\n(Warning: u need collect money first,)",
        Callback = function(v) 
            collectMoneyEnabled = v
            
            if v then
                task.spawn(function()
                    task.wait(0.2)
                    collectMoney(1)
                    
                    if plotUUID then
                        startCollectMoneyLoop()
                        WindUI:Notify({
                            Title = "Auto Collect",
                            Content = "Started collecting money!",
                            Duration = 4
                        })
                    end
                end)
            end 
        end
    })
    
    AutoFarmTab:Slider({
        Title = "Money Collection Speed",
        Desc = "How many slots to process at once (lower = faster)",
        Step = 1,
        Value = {Min = 1, Max = 30, Default = 5},
        Callback = function(v) 
            moneyCylinderSize = v
        end
    })
    
    AutoFarmTab:Section({Title = "Brainroot Upgrade"})
    AutoFarmTab:Toggle({
        Title = "Auto Upgrade Brainroot",
        Desc = "Automatically upgrade brainroots in selected slots\n(Warning: u need collect money first)",
        Callback = function(v) 
            upgradeBrainrotEnabled = v
            
            if v then
                task.spawn(function()
                    task.wait(0.2)
                    if plotUUID then
                        startUpgradeBrainrootLoop()
                        WindUI:Notify({
                            Title = "Auto Upgrade",
                            Content = "Started upgrading brainroots!",
                            Duration = 4
                        })
                    end
                end)
            end 
        end
    })
    
    AutoFarmTab:Slider({
        Title = "Brainroot Upgrade Speed",
        Desc = "How many slots to upgrade at once (lower = faster)",
        Step = 1,
        Value = {Min = 1, Max = 30, Default = 5},
        Callback = function(v) 
            upgradeCylinderSize = v
        end
    })
    
    local slotOptions = {}
    for i = 1, 30 do
        table.insert(slotOptions, "Slot " .. i)
    end
    
    AutoFarmTab:Dropdown({
        Title = "Select Slots to Upgrade",
        Desc = "Choose which slots to upgrade",
        Values = slotOptions,
        Value = selectedUpgradeSlots,
        Multi = true,
        AllowNone = false,
        Callback = function(v) 
            selectedUpgradeSlots = v
            for i, slotName in ipairs(selectedUpgradeSlots) do
                selectedUpgradeSlots[i] = slotName:gsub("Slot ", "")
            end
        end
    })
    
    AutoFarmTab:Section({Title = "Radioactive Coins"})
    AutoFarmTab:Toggle({
        Title = "Auto Collect Radioactive Coins",
        Desc = "Automatically collect all radioactive coins\n(Warning: use noclip on setting to avoid get phussing)",
        Callback = function(v)
            collectRadioactiveCoinsEnabled = v
            
            if v then
                startCoinCollectionLoop()
                WindUI:Notify({
                    Title = "Coin Collection",
                    Content = "Started collecting radioactive coins!",
                    Duration = 2
                })
            else
                stopCoinCollection()
                WindUI:Notify({
                    Title = "Coin Collection",
                    Content = "Stopped collecting radioactive coins!",
                    Duration = 2
                })
            end
        end
    })
    
    AutoFarmTab:Slider({
        Title = "Coin Collection Amount",
        Desc = "How many coins to collect at once (lower = less lag)",
        Step = 1,
        Value = {Min = 1, Max = 50, Default = 10},
        Callback = function(v) 
            coinCylinderSize = v
        end
    })
    
    AutoFarmTab:Slider({
        Title = "Coin Collection Radius",
        Desc = "Distance from player to collect coins",
        Step = 0.5,
        Value = {Min = 1, Max = 10, Default = 3},
        Callback = function(v) 
            coinRadius = v
        end
    })
    
    AutoFarmTab:Slider({
        Title = "Coin Collection Height",
        Desc = "Height above player to collect coins",
        Step = 0.5,
        Value = {Min = -5, Max = 10, Default = 2},
        Callback = function(v) 
            coinHeight = v
        end
    })
    
    AutoFarmTab:Section({Title = "Upgrades"})
    AutoFarmTab:Toggle({
        Title = "Auto Upgrade Speed",
        Desc = "Upgrade speed values simultaneously",
        Callback = function(v) 
            upgradeSpeedEnabled = v 
            if v then 
                startUpgradeSpeedLoop()
                WindUI:Notify({
                    Title = "Auto Upgrade",
                    Content = "Started upgrading speed!",
                    Duration = 2
                })
            end 
        end
    })
    AutoFarmTab:Dropdown({
        Title = "Speed Upgrade Values",
        Desc = "Choose which speed values to upgrade",
        Values = {"1","5","10"},
        Value = {"1","5","10"},
        Multi = true,
        AllowNone = false,
        Callback = function(v) 
            selectedSpeedValues = v 
        end
    })
    AutoFarmTab:Section({Title = "Progression"})
    AutoFarmTab:Toggle({
        Title = "Auto Rebirth", 
        Desc = "Auto rebirth for x money",
        Callback = function(v) 
            rebirthEnabled = v 
            if v then 
                startRebirthLoop()
                WindUI:Notify({
                    Title = "Auto Rebirth",
                    Content = "Started auto rebirth!",
                    Duration = 2
                })
            end 
        end
    })
    AutoFarmTab:Toggle({
        Title = "Auto Upgrade Carry", 
        Desc = "Auto upgrade carry capacity",
        Callback = function(v) 
            carryUpgradeEnabled = v 
            if v then 
                startCarryUpgradeLoop()
                WindUI:Notify({
                    Title = "Auto Upgrade",
                    Content = "Started upgrading carry!",
                    Duration = 2
                })
            end 
        end
    })
    AutoFarmTab:Toggle({
        Title = "Auto Upgrade Base", 
        Desc = "Auto upgrade base for more slots",
        Callback = function(v) 
            upgradeBaseEnabled = v 
            if v then 
                startUpgradeBaseLoop()
                WindUI:Notify({
                    Title = "Auto Upgrade",
                    Content = "Started upgrading base!",
                    Duration = 2
                })
            end 
        end
    })

    -- LUCKY BLOCK FARM TAB (HOME RETURN VERSION)
    local LuckyBlockFarmTab = Window:Tab({Title = "Lucky Block Farm", Icon = "solar:gift-bold", Color = Color3.fromRGB(255, 105, 180)})

    LuckyBlockFarmTab:Section({Title = "Lucky Block Auto Farm"})
    luckyBlockFarmStatus = LuckyBlockFarmTab:Paragraph({
        Title = "Status",
        Desc = "Idle",
        Image = "activity",
        ImageSize = 20
    })

    LuckyBlockFarmTab:Toggle({
        Title = "Auto Farm Lucky Blocks (Home Return)",
        Desc = "Collect Lucky Blocks and return home after each collection",
        Callback = function(v)
            luckyBlockFarmEnabled = v
            luckyBlockFarmFlag.Value = v
            
            if v then
                startLuckyBlockFarmLoop()
                WindUI:Notify({
                    Title = "Lucky Block Farm",
                    Content = "Started Lucky Block farm with home return!",
                    Duration = 2
                })
            else
                if luckyBlockFarmStatus then
                    luckyBlockFarmStatus:SetDesc("Stopped")
                end
                WindUI:Notify({
                    Title = "Lucky Block Farm",
                    Content = "Stopped Lucky Block farm!",
                    Duration = 2
                })
            end
        end
    })

    LuckyBlockFarmTab:Dropdown({
        Title = "Select Lucky Block Rarities",
        Desc = "Choose which Lucky Block rarities to farm",
        Values = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythical", "Cosmic", "Secret", "Celestial", "Divine"},
        Value = selectedLuckyBlockRaritiesForFarm,
        Multi = true,
        AllowNone = false,
        Callback = function(v)
            selectedLuckyBlockRaritiesForFarm = v
        end
    })

    LuckyBlockFarmTab:Section({Title = "Lucky Block Teleport"})

    local luckyBlockTypeDD = LuckyBlockFarmTab:Dropdown({
        Title = "Lucky Block Type",
        Values = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythical", "Cosmic", "Secret", "Celestial", "Divine"},
        Value = "Common",
        Callback = function(v)
            selectedLuckyBlockType = v
        end
    })

    LuckyBlockFarmTab:Button({
        Title = "Teleport to Random Lucky Block",
        Callback = function()
            local luckyBlocksFolder = Workspace:FindFirstChild("ActiveLuckyBlocks")
            if not luckyBlocksFolder then
                WindUI:Notify({
                    Title = "Error",
                    Content = "No Lucky Blocks found in the game!",
                    Duration = 2
                })
                return
            end
            
            local matchingBlocks = {}
            for _, obj in ipairs(luckyBlocksFolder:GetChildren()) do
                local rarity = getRarity(obj.Name)
                if rarity and rarity == selectedLuckyBlockType then
                    local adornee = getAdornee(obj)
                    if adornee then
                        table.insert(matchingBlocks, {Object = obj, Position = adornee.Position})
                    end
                end
            end
            
            if #matchingBlocks > 0 then
                local randomBlock = matchingBlocks[math.random(1, #matchingBlocks)]
                local success = TeleportTo(randomBlock.Position + Vector3.new(0, 3, 0))
                
                if success then
                    WindUI:Notify({
                        Title = "Teleport",
                        Content = "Teleported to " .. selectedLuckyBlockType .. " Lucky Block!",
                        Duration = 2
                    })
                else
                    WindUI:Notify({
                        Title = "Error",
                        Content = "Failed to teleport to Lucky Block!",
                        Duration = 2
                    })
                end
            else
                WindUI:Notify({
                    Title = "Error",
                    Content = "No " .. selectedLuckyBlockType .. " Lucky Blocks found!",
                    Duration = 2
                })
            end
        end
    })

    LuckyBlockFarmTab:Button({
        Title = "Teleport to Nearest Lucky Block",
        Callback = function()
            local nearestLuckyBlock = getNearestLuckyBlock()
            if nearestLuckyBlock then
                local success = TeleportTo(nearestLuckyBlock.Position + Vector3.new(0, 3, 0))
                
                if success then
                    WindUI:Notify({
                        Title = "Teleport",
                        Content = "Teleported to nearest " .. nearestLuckyBlock.Rarity .. " Lucky Block!",
                        Duration = 2
                    })
                else
                    WindUI:Notify({
                        Title = "Error",
                        Content = "Failed to teleport to Lucky Block!",
                        Duration = 2
                    })
                end
            else
                WindUI:Notify({
                    Title = "Error",
                    Content = "No Lucky Blocks found!",
                    Duration = 2
                })
            end
        end
    })

    LuckyBlockFarmTab:Button({
        Title = "Teleport to Highest Priority Lucky Block",
        Callback = function()
            local targetLuckyBlock = getHighestPriorityLuckyBlock()
            if targetLuckyBlock then
                local success = TeleportTo(targetLuckyBlock.Position + Vector3.new(0, 3, 0))
                
                if success then
                    WindUI:Notify({
                        Title = "Teleport",
                        Content = "Teleported to " .. targetLuckyBlock.Rarity .. " Lucky Block (Priority: " .. (luckyBlockPriority[targetLuckyBlock.Rarity] or 0) .. ")!",
                        Duration = 2
                    })
                else
                    WindUI:Notify({
                        Title = "Error",
                        Content = "Failed to teleport to Lucky Block!",
                        Duration = 2
                    })
                end
            else
                WindUI:Notify({
                    Title = "Error",
                    Content = "No Lucky Blocks found!",
                    Duration = 2
                })
            end
        end
    })
    
    -- ESP TAB
    local ESPTab = Window:Tab({Title = "ESP", Icon = "solar:eye-bold", Color = Color3.fromRGB(255, 105, 180)})
    
    ESPTab:Section({Title = "Brainroot ESP"})
    ESPTab:Toggle({
        Title = "Brainroot ESP",
        Desc = "Show selected brainroots with colors",
        Callback = function(v)
            toggleBrainrootEsp(v)
            WindUI:Notify({
                Title = "Brainroot ESP",
                Content = v and "Enabled" or "Disabled",
                Duration = 2
            })
        end
    })
    
    ESPTab:Dropdown({
        Title = "Select Floors for ESP",
        Desc = "Choose which floors to display",
        Values = {"Common Floor", "Uncommon Floor", "Rare Floor", "Epic Floor", "Legendary Floor", "Mythical Floor", "Cosmic Floor", "Secret Floor", "Celestial Floor"},
        Value = selectedFloorsForEsp,
        Multi = true,
        AllowNone = false,
        Callback = function(v)
            selectedFloorsForEsp = v
            if brainrootEspEnabled then
                updateEsp()
                if brainrootMonitorConnection then
                    brainrootMonitorConnection:Disconnect()
                    brainrootMonitorConnection = nil
                end
                startEspMonitoring()
            end
        end
    })
    
    ESPTab:Section({Title = "Player ESP"})
    ESPTab:Toggle({
        Title = "Player ESP",
        Desc = "Show players with boxes and names",
        Callback = function(v)
            togglePlayerEsp(v)
            WindUI:Notify({
                Title = "Player ESP",
                Content = v and "Enabled" or "Disabled",
                Duration = 2
            })
        end
    })
    
    ESPTab:Section({Title = "Lucky Block ESP"})
    ESPTab:Toggle({
        Title = "Lucky Block ESP",
        Desc = "Show selected Lucky Blocks with colors",
        Callback = function(v)
            toggleLuckyBlockEsp(v)
            if v then
                setupLuckyBlockAutoDetect()
            end
            WindUI:Notify({
                Title = "Lucky Block ESP",
                Content = v and "Enabled" or "Disabled",
                Duration = 2
            })
        end
    })
    
    ESPTab:Dropdown({
        Title = "Select Lucky Block Rarities",
        Desc = "Choose which Lucky Block rarities to display",
        Values = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythical", "Cosmic", "Secret", "Celestial", "Divine"},
        Value = selectedLuckyBlockRarities,
        Multi = true,
        AllowNone = false,
        Callback = function(v)
            selectedLuckyBlockRarities = v
            if luckyBlockEspEnabled then
                updateEsp()
            end
        end
    })
    
    -- SELL TAB
    local SellTab = Window:Tab({Title = "Sell", Icon = "solar:wallet-money-bold", Color = Color3.fromRGB(255, 105, 180)})
    SellTab:Section({Title = "Sell Options"})
    SellTab:Toggle({
        Title = "Auto Sell Brainroot", 
        Desc = "Automatically sell brainroot in hand",
        Callback = function(v) 
            sellBrainrootEnabled = v
            if v then 
                startSellBrainrootLoop()
                WindUI:Notify({
                    Title = "Auto Sell",
                    Content = "Started selling brainroot!",
                    Duration = 2
                })
            end 
        end
    })
    SellTab:Toggle({
        Title = "Auto Sell All", 
        Desc = "Automatically sell all brainroots",
        Callback = function(v) 
            sellAllEnabled = v
            if v then 
                startSellAllLoop()
                WindUI:Notify({
                    Title = "Auto Sell",
                    Content = "Started selling all!",
                    Duration = 2
                })
            end 
        end
    })

    SellTab:Section({Title = "Wheel Spin"})
    SellTab:Toggle({
        Title = "Auto Spin Wheel", 
        Desc = "Automatically spin the wheel for rewards",
        Callback = function(v) 
            autoSpinEnabled = v
            if v then 
                if autoSpinInitialized then
                    startAutoSpinLoop()
                    WindUI:Notify({
                        Title = "Auto Spin",
                        Content = "Started auto spinning wheel!",
                        Duration = 2
                    })
                else
                    autoSpinInitialized = true
                    WindUI:Notify({
                        Title = "Auto Spin",
                        Content = "Auto spin enabled! Will start on next manual toggle.",
                        Duration = 2
                    })
                end
            end 
        end
    })
    SellTab:Slider({
        Title = "Spin Cooldown (seconds)",
        Step = 0.1,
        Value = {Min = 0.5, Max = 5, Default = 1},
        Callback = function(v) 
            spinCooldown = v
        end
    })

    local priceDisplay = SellTab:Paragraph({
        Title = "Current Brainroot Price",
        Desc = "Price: 0",
        BackgroundColor = Color3.fromRGB(0, 0, 0)
    })

    SellTab:Button({
        Title = "Check Brainroot Price",
        Callback = function()
            local success, price = pcall(checkPrice)
            if success and price then 
                currentBrainrootPrice = price
                if priceDisplay then
                    priceDisplay:SetDesc("Price: " .. tostring(currentBrainrootPrice))
                end
                WindUI:Notify({
                    Title = "Price Check",
                    Content = "Current brainroot price: " .. tostring(currentBrainrootPrice),
                    Duration = 2
                })
            else
                WindUI:Notify({
                    Title = "Error",
                    Content = "Failed to check brainroot price",
                    Duration = 2
                })
            end
        end
    })
    
    -- TELEPORT TAB
    local TeleportTab = Window:Tab({Title = "Teleport", Icon = "solar:map-bold", Color = Color3.fromRGB(255, 105, 180)})
    
    TeleportTab:Section({Title = "Auto Gap"})
    local selectedGapName = "Gap1"
    local gapFlag = {Value = false}
    local autoGapStatus = TeleportTab:Paragraph({
        Title = "Status",
        Desc = "Idle",
        Image = "activity",
        ImageSize = 20
    })

    TeleportTab:Dropdown({
        Title = "Select Target Gap",
        Desc = "Choose the gap you want to move to",
        Values = {"Gap1", "Gap2", "Gap3", "Gap4", "Gap5", "Gap6", "Gap7", "Gap8", "Gap9"},
        Value = "Gap1",
        Callback = function(v)
            selectedGapName = v
        end
    })

    TeleportTab:Toggle({
        Title = "Auto go to Gap (Beta",
        Desc = "Automatically move to the selected gap",
        Callback = function(v)
            gapFlag.Value = v
            if v then
                local targetGapData = nil
                for _, gap in ipairs(GAPS) do
                    if gap.Name == selectedGapName then
                        targetGapData = gap
                        break
                    end
                end

                if targetGapData then
                    task.spawn(function()
                        smartMove(targetGapData, gapFlag, TWEEN_SPEED, autoGapStatus)
                        if autoGapStatus then autoGapStatus:SetDesc("Idle") end
                    end)
                else
                    WindUI:Notify({Title = "Error", Content = "Selected gap not found!", Duration = 3})
                    gapFlag.Value = false
                end
            else
                if autoGapStatus then autoGapStatus:SetDesc("Stopped") end
            end
        end
    })
    
    TeleportTab:Section({Title = "Teleport Mode"})
    TeleportTab:Dropdown({
        Title = "Teleport Mode",
        Desc = "Choose between Tween or Instant teleport",
        Values = {"Tween", "Instant"},
        Value = "Tween",
        Callback = function(v) 
            teleportMode = v
        end
    })
    
    TeleportTab:Section({Title = "Brainroot Teleport"})
    local typeDD = TeleportTab:Dropdown({
        Title = "Brainroot Type",
        Values = brainrootTypes,
        Value = 1,
        Callback = function(v)
            selectedBrainrootType = v
            updateBrainrootNames()
            if brainrootIncomeList[selectedBrainrootType] and #brainrootIncomeList[selectedBrainrootType] > 0 then
                incomeDD:Refresh(brainrootIncomeList[selectedBrainrootType])
                selectedBrainrootIncome = brainrootIncomeList[selectedBrainrootType][1] or ""
            end
        end
    })
    local incomeDD = TeleportTab:Dropdown({
        Title = "Brainroot Income ($/s)",
        Values = brainrootIncomeList["Common"] or {},
        Value = 1,
        Callback = function(v) 
            selectedBrainrootIncome = v
        end
    })
    TeleportTab:Button({
        Title = "Refresh Brainroot List",
        Callback = function()
            updateBrainrootNames()
            if brainrootIncomeList[selectedBrainrootType] then
                incomeDD:Refresh(brainrootIncomeList[selectedBrainrootType])
            end
            WindUI:Notify({
                Title = "Brainroot List",
                Content = "Brainroot list refreshed",
                Duration = 2
            })
        end
    })
    TeleportTab:Button({
        Title = "Teleport to Selected Brainroot",
        Callback = function()
            if selectedBrainrootIncome ~= "" then
                if teleportToBrainroot(selectedBrainrootType, selectedBrainrootIncome) then
                    WindUI:Notify({
                        Title = "Teleport", 
                        Content = "Teleported to " .. selectedBrainrootType .. " brainroot with $" .. selectedBrainrootIncome .. "/s",
                        Duration = 2
                    })
                else
                    WindUI:Notify({
                        Title = "Error",
                        Content = "Brainroot not found",
                        Duration = 2
                    })
                end
            else
                WindUI:Notify({
                    Title = "Error",
                    Content = "Please select a valid income value",
                    Duration = 2
                })
            end
        end
    })
    
    TeleportTab:Section({Title = "Floor Navigation"})
    floorStatus = TeleportTab:Paragraph({
        Title = "Current Location",
        Desc = floorPositions[1].name,
        BackgroundColor = Color3.fromRGB(0, 0, 0)
    })
    TeleportTab:Button({
        Title = " Previous Floor",
        Callback = function()
            if currentFloorIndex > 1 then
                currentFloorIndex = currentFloorIndex - 1
                teleportToFloor(currentFloorIndex)
                floorStatus:SetDesc(floorPositions[currentFloorIndex].name)
            else
                WindUI:Notify({Title = "Floor", Content = "Already at the first floor!", Duration = 2})
            end
        end
    })
    TeleportTab:Button({
        Title = "Next Floor ",
        Callback = function()
            if currentFloorIndex < #floorPositions then
                currentFloorIndex = currentFloorIndex + 1
                teleportToFloor(currentFloorIndex)
                floorStatus:SetDesc(floorPositions[currentFloorIndex].name)
            else
                WindUI:Notify({Title = "Floor", Content = "Already at the last floor!", Duration = 2})
            end
        end
    })
    
    TeleportTab:Button({
        Title = "Refresh Current Floor",
        Callback = function()
            teleportToFloor(currentFloorIndex)
            WindUI:Notify({
                Title = "Floor Teleport",
                Content = "Refreshed current floor: " .. floorPositions[currentFloorIndex].name,
                Duration = 2
            })
        end
    })
    
    TeleportTab:Button({
        Title = "Reset to Home",
        Callback = function()
            currentFloorIndex = 1
            teleportToFloor(currentFloorIndex)
            floorStatus:SetDesc(floorPositions[currentFloorIndex].name)
            WindUI:Notify({
                Title = "Floor Teleport",
                Content = "Reset to Home",
                Duration = 2
            })
        end
    })
    
    -- SERVER MANAGEMENT TAB
    local ServerTab = Window:Tab({Title = "Server", Icon = "solar:server-bold", Color = Color3.fromRGB(255, 105, 180)})
    
    ServerTab:Section({Title = "Server Information"})
    local serverIdDisplay = ServerTab:Paragraph({
        Title = "Current Server ID",
        Desc = "Loading...",
        BackgroundColor = Color3.fromRGB(0, 0, 0)
    })
    
    task.spawn(function()
        while task.wait(1) do
            if serverIdDisplay then
                serverIdDisplay:SetDesc(getServerId())
            end
        end
    end)
    
    ServerTab:Button({
        Title = "Copy Server ID",
        Callback = function()
            copyServerId()
        end
    })
    
    ServerTab:Section({Title = "Server Actions"})
    ServerTab:Button({
        Title = "Rejoin Server",
        Callback = function()
            rejoinServer()
        end
    })
    
    ServerTab:Button({
        Title = "Server Hop (Random)",
        Callback = function()
            serverHop()
        end
    })
    
    ServerTab:Button({
        Title = "Server Hop (Lower Player Count)",
        Callback = function()
            serverHopLowerPlayer()
        end
    })
    
    ServerTab:Section({Title = "Join Server"})
    local serverIdInput = ServerTab:Input({
        Title = "Server ID",
        Desc = "Enter server ID to join",
        Placeholder = "Enter server ID...",
        Callback = function(text)
            if text and text ~= "" then
                joinServer(text)
            end
        end
    })
    
    -- SETTINGS TAB
    local SettingsTab = Window:Tab({Title = "Settings", Icon = "solar:settings-bold", Color = Color3.fromRGB(255, 105, 180)})
    SettingsTab:Section({Title = "Character"})
    SettingsTab:Slider({
        Title = "Walk Speed", 
        Step = 1,
        Value = {Min = 16, Max = 200, Default = 16},
        Callback = function(v) 
            if GetHum() then 
                GetHum().WalkSpeed = v 
            end 
        end 
    })
    SettingsTab:Slider({
        Title = "Jump Power", 
        Step = 1,
        Value = {Min = 50, Max = 200, Default = 50},
        Callback = function(v) 
            if GetHum() then 
                GetHum().JumpPower = v 
            end 
        end 
    })
    
    SettingsTab:Button({
        Title = "Unlock Camera Zoom",
        Callback = function()
            player.CameraMaxZoomDistance = math.huge
            WindUI:Notify({
                Title = "Camera",
                Content = "Camera zoom distance unlocked!",
                Duration = 2
            })
        end
    })
    
    SettingsTab:Section({Title = "Fly"})
    SettingsTab:Toggle({
        Title = "Enable Fly (Press E)",
        Callback = function(v) 
            flyEnabled = v 
        end 
    })
    SettingsTab:Slider({
        Title = "Fly Speed", 
        Step = 1,
        Value = {Min = 10, Max = 200, Default = 50},
        Callback = function(v) 
            speed = v 
        end 
    })
    SettingsTab:Section({Title = "Noclip"})
    local noclipEnabled = false
    SettingsTab:Toggle({
        Title = "Enable Noclip",
        Callback = function(v)
            noclipEnabled = v
            toggleNoclip(v)
            WindUI:Notify({
                Title = "Noclip",
                Content = v and "Enabled" or "Disabled",
                Duration = 2
            })
        end
    })
    
    SettingsTab:Section({Title = "Hitbox"})
    SettingsTab:Toggle({
        Title = "Enable Hitbox",
        Desc = "Expand hitboxes of other players",
        Callback = function(v)
            hitboxEnabled = v
            if v then
                startHitboxLoop()
                WindUI:Notify({
                    Title = "Hitbox",
                    Content = "Hitbox enabled!",
                    Duration = 2
                })
            else
                clearHitboxes()
                WindUI:Notify({
                    Title = "Hitbox",
                    Content = "Hitbox disabled!",
                    Duration = 2
                })
            end
        end
    })
    SettingsTab:Slider({
        Title = "Hitbox Size",
        Step = 1,
        Value = {Min = 1, Max = 20, Default = 5},
        Callback = function(v)
            hitboxSize = v
        end
    })
    SettingsTab:Slider({
        Title = "Hitbox Transparency",
        Step = 0.1,
        Value = {Min = 0, Max = 1, Default = 0.7},
        Callback = function(v)
            hitboxTransparency = v
        end
    })
    SettingsTab:Button({
        Title = "Red Hitbox",
        Callback = function()
            hitboxColor = Color3.new(1, 0, 0)
            WindUI:Notify({
                Title = "Hitbox Color",
                Content = "Changed to red!",
                Duration = 2
            })
        end
    })
    SettingsTab:Button({
        Title = "Green Hitbox",
        Callback = function()
            hitboxColor = Color3.new(0, 1, 0)
            WindUI:Notify({
                Title = "Hitbox Color",
                Content = "Changed to green!",
                Duration = 2
            })
        end
    })
    SettingsTab:Button({
        Title = "Blue Hitbox",
        Callback = function()
            hitboxColor = Color3.new(0, 0, 1)
            WindUI:Notify({
                Title = "Hitbox Color",
                Content = "Changed to blue!",
                Duration = 2
            })
        end
    })
    
    SettingsTab:Section({Title = "Protection"})
    SettingsTab:Toggle({
        Title = "Anti-Ragdoll",
        Desc = "Prevent ragdoll state",
        Callback = function(v)
            antiRagdollEnabled = v
            if v then
                enableAntiRagdoll()
                WindUI:Notify({
                    Title = "Anti-Ragdoll",
                    Content = "Anti-ragdoll enabled!",
                    Duration = 2
                })
            else
                disableAntiRagdoll()
                WindUI:Notify({
                    Title = "Anti-Ragdoll",
                    Content = "Anti-ragdoll disabled!",
                    Duration = 2
                })
            end
        end
    })
    
    SettingsTab:Toggle({
        Title = "Extra Life beta (1-2 Life)",
        Desc = "Prevent death (but u still die when get hit tsunami 2/3 time)",
        Callback = function(v)
            toggleExtraLife(v)
        end
    })
    
    SettingsTab:Section({Title = "Event Tracker"})
    SettingsTab:Toggle({
        Title = "Enable Event Tracker",
        Desc = "Track Celestial and Radioactive event timers",
        Callback = function(v)
            toggleEventTracker(v)
        end
    })
    
    SettingsTab:Section({Title = "Utilities"})
    SettingsTab:Toggle({
        Title = "Instant Take Brainroot",
        Callback = function(v)
            instantTakeEnabled = v
            if v then setupInstantTake() end
        end
    })
    
    UserInputService.InputBegan:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.E and flyEnabled then
            flying = not flying
            if flying then 
                startFly() 
            else 
                stopFly() 
            end
        end
    end)
    
    WindUI:Notify({
        Title = "Cyraa Hub Loaded",
        Content = "Escape Tsunami For Brainrots! v1.0.5 Loaded\nMade by komtolmmek2 script",
        Duration = 4
    })
    
    autoSpinInitialized = true
    
    scanForLabels()
    Workspace.DescendantAdded:Connect(function()
        if not celestialLabel or not radioactiveLabel then
            scanForLabels()
        end
    end)
    
    setupPlayerEspRespawnHandling()
    
    setupLuckyBlockAutoDetect()
    
    toggleEventTracker(true)
end)

player.CharacterAdded:Connect(function()
    task.delay(1.5, function()
        if instantTakeEnabled then setupInstantTake() end
        currentFloorIndex = 1
        if floorStatus then
            floorStatus:SetDesc(floorPositions[currentFloorIndex].name)
        end
        plotUUID = nil
        lastAction = ""
        lastUUID = ""
        lastSlot = ""
        findPlotRemote()
        if brainrootEspEnabled then
            toggleBrainrootEsp(false)
            task.wait(0.1)
            toggleBrainrootEsp(true)
        end
        if playerEspEnabled then
            togglePlayerEsp(false)
            task.wait(0.1)
            togglePlayerEsp(true)
        end
        if luckyBlockEspEnabled then
            toggleLuckyBlockEsp(false)
            task.wait(0.1)
            toggleLuckyBlockEsp(true)
            setupLuckyBlockAutoDetect()
        end
        if collectRadioactiveCoinsEnabled then
            stopCoinCollection()
            task.wait(0.5)
            startCoinCollectionLoop()
        end
        if antiRagdollEnabled then
            enableAntiRagdoll()
        end
        if hitboxEnabled then
            clearHitboxes()
            task.wait(0.5)
            startHitboxLoop()
        end
        if eventTrackerEnabled then
            toggleEventTracker(false)
            task.wait(0.1)
            toggleEventTracker(true)
        end
        if upgradeBrainrotEnabled then
            task.wait(0.5)
            startUpgradeBrainrootLoop()
        end
        if extraLifeEnabled then
            task.wait(0.5)
            applyAntiDie(player.Character)
        end
        if backpackInfoParagraph then
            updateBackpackInfo()
        end
    end)
end)

print("this script made by komtolmmek2 script")
