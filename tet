-- tsunami for brainroot
-- v1.0.5

-- ===================== SERVICES =====================
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local RS = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local StarterGui = game:GetService("StarterGui")
local player = Players.LocalPlayer

-- ===================== CONFIG =====================
local CHECK_INTERVAL = 0.03
local GROUND_OFFSET = 3
local DETECTION_DISTANCE = 120
local TWEEN_SPEED = 350
local FORCE_BACK_SPEED = 300

-- ===================== GAP SETUP =====================
local GAPS = {
    {Name="Gap1",Part=Workspace.Misc.Gaps.Gap1:GetChildren()[2]},
    {Name="Gap2",Part=Workspace.Misc.Gaps.Gap2:GetChildren()[2]},
    {Name="Gap3",Part=Workspace.Misc.Gaps.Gap3:GetChildren()[2]},
    {Name="Gap4",Part=Workspace.Misc.Gaps.Gap4:GetChildren()[2]},
    {Name="Gap5",Part=Workspace.Misc.Gaps.Gap5:GetChildren()[2]},
    {Name="Gap6",Part=Workspace.Misc.Gaps.Gap6.Mud},
    {Name="Gap7",Part=Workspace.Misc.Gaps.Gap7:GetChildren()[2]},
    {Name="Gap8",Part=Workspace.Misc.Gaps.Gap8:GetChildren()[2]},
    {Name="Gap9",Part=Workspace.Misc.Gaps.Gap9:GetChildren()[2]},
}

-- Gap to rarity mapping
local GAP_TO_RARITY = {
    ["Gap1"] = "Common",
    ["Gap2"] = "Uncommon",
    ["Gap3"] = "Rare",
    ["Gap4"] = "Epic",
    ["Gap5"] = "Legendary",
    ["Gap6"] = "Mythical",
    ["Gap7"] = "Cosmic",
    ["Gap8"] = "Secret",
    ["Gap9"] = "Celestial"
}

-- Home coordinates
local HOME_POSITION = CFrame.new(121, 3, 39)

-- ===================== UTILS =====================
local function getChar()
    return player.Character or player.CharacterAdded:Wait()
end

local function getHRP()
    local char = getChar()
    local hrp = char:WaitForChild("HumanoidRootPart", 5)
    if not hrp then
        repeat task.wait(0.1)
            hrp = char:FindFirstChild("HumanoidRootPart")
        until hrp
    end
    return hrp
end

local function getHumanoid()
    return getChar():FindFirstChild("Humanoid")
end

local function getGroundCFrame(pos)
    return CFrame.new(pos.X, pos.Y + GROUND_OFFSET, pos.Z)
end

-- ===================== TSUNAMI =====================
local function getNearestTsunami()
    local folder = Workspace:FindFirstChild("ActiveTsunamis")
    if not folder then return nil end

    local hrp = getHRP()
    local nearest, dist = nil, math.huge

    for _, w in ipairs(folder:GetChildren()) do
        local hb = w:FindFirstChild("Hitbox", true)
        if hb then
            local d = (hb.Position - hrp.Position).Magnitude
            if d < dist then
                dist = d
                nearest = hb
            end
        end
    end
    return nearest
end

local function isTsunamiNear(pos)
    local tsu = getNearestTsunami()
    if not tsu then return false end
    return (tsu.Position - pos).Magnitude <= DETECTION_DISTANCE
end

-- ===================== FORCE BACK =====================
local function getNearestGap(currentPos)
    local nearest = nil
    local minDist = math.huge
    
    for _, gap in ipairs(GAPS) do
        local dist = (gap.Part.Position - currentPos).Magnitude
        if dist < minDist and dist > 2 then
            minDist = dist
            nearest = gap
        end
    end
    
    return nearest, minDist
end

local function forceBackWithTween()
    local hrp = getHRP()
    local humanoid = getHumanoid()
    local currentPos = hrp.Position
    
    local nearestGap, gapDist = getNearestGap(currentPos)
    
    if nearestGap then
        local targetCF = getGroundCFrame(nearestGap.Part.Position)
        
        local tween = TweenService:Create(
            hrp,
            TweenInfo.new(gapDist / FORCE_BACK_SPEED, Enum.EasingStyle.Linear),
            {CFrame = targetCF}
        )
        tween:Play()
        
        local startTime = tick()
        while tween.PlaybackState == Enum.PlaybackState.Playing do
            hrp.Velocity = Vector3.zero
            if humanoid then humanoid.Jump = false end
            if tick() - startTime > (gapDist / FORCE_BACK_SPEED + 1) then
                tween:Cancel()
                hrp.CFrame = targetCF
                break
            end
            task.wait(CHECK_INTERVAL)
        end
    end
end

-- ===================== SMART MOVE =====================
local function smartMove(target, flag, speed, statusParagraph)
    local hrp = getHRP()
    local humanoid = getHumanoid()
    
    -- Tunggu aman dari tsunami sebelum memulai
    while isTsunamiNear(hrp.Position) and flag.Value do
        if statusParagraph then statusParagraph:SetDesc("Tsunami detected! Waiting...") end
        hrp.Velocity = Vector3.zero
        if humanoid then humanoid.Jump = false end
        forceBackWithTween()
        task.wait(CHECK_INTERVAL)
    end
    
    local targetPos = target.Part and target.Part.Position or target.Position
    local dist = (hrp.Position - targetPos).Magnitude
    local targetCF = getGroundCFrame(targetPos)
    
    if statusParagraph then statusParagraph:SetDesc("Moving to target...") end
    
    local tween = TweenService:Create(hrp, TweenInfo.new(dist / speed, Enum.EasingStyle.Linear), {CFrame = targetCF})
    tween:Play()
    
    local startTime = tick()
    while tween.PlaybackState == Enum.PlaybackState.Playing do
        if not flag.Value then 
            tween:Cancel() 
            return false
        end
        
        hrp.Velocity = Vector3.zero
        if humanoid then humanoid.Jump = false end
        
        if isTsunamiNear(hrp.Position) then
            tween:Cancel()
            forceBackWithTween()
            return false
        end
        
        if tick() - startTime > dist / speed + 2 then
            tween:Cancel()
            hrp.CFrame = targetCF
            break
        end
        task.wait(CHECK_INTERVAL)
    end
    
    return true
end

-- ===================== BRAINROOT FUNCTIONS =====================
local function waitForBrainroot(rarity)
    local brainroots = Workspace:FindFirstChild("ActiveBrainrots")
    if not brainroots then return false end
    local folder = brainroots:FindFirstChild(rarity)
    if not folder then return false end
    
    local startTime = tick()
    local timeout = 15
    while #folder:GetChildren() == 0 and tick() - startTime < timeout do 
        task.wait(0.5) 
    end
    return #folder:GetChildren() > 0
end

local function getHighestIncomeBrainroot(rarity)
    local brainroots = Workspace:FindFirstChild("ActiveBrainrots")
    if not brainroots then return nil end
    local folder = brainroots:FindFirstChild(rarity)
    if not folder then return nil end
    
    local highestIncome = 0
    local targetBrainroot = nil
    
    for _, b in pairs(folder:GetChildren()) do
        if b:IsA("Model") then
            local income = 0
            for _, c in ipairs(b:GetDescendants()) do
                if c:IsA("TextLabel") and c.Text:find("%$") then
                    local amount = c.Text:match("%$(.+)%/s")
                    if amount then 
                        income = tonumber(amount) or 0
                        if income > highestIncome then
                            highestIncome = income
                            targetBrainroot = b
                        end
                        break
                    end
                end
            end
        end
    end
    
    return targetBrainroot, highestIncome
end

-- ===================== COLLECT BRAINROOT SAFE =====================
local function collectBrainroot(brainroot, statusParagraph)
    if not brainroot then return false end
    
    local targetPart = brainroot.PrimaryPart or brainroot:FindFirstChildWhichIsA("BasePart")
    if not targetPart then return false end
    
    local flag = {Value = true}
    
    -- Move to brainroot
    local success = smartMove({Part = targetPart}, flag, TWEEN_SPEED, statusParagraph)
    if not success then return false end
    
    -- Hold E to collect
    if statusParagraph then statusParagraph:SetDesc("Collecting brainroot...") end
    
    local hrp = getHRP()
    local humanoid = getHumanoid()
    local holdTime = 2
    local startHold = tick()
    
    while tick() - startHold < holdTime do
        if isTsunamiNear(hrp.Position) then
            if statusParagraph then statusParagraph:SetDesc("Tsunami detected! Running back...") end
            forceBackWithTween()
            task.wait(0.5)
            startHold = tick()
        else
            hrp.Velocity = Vector3.zero
            if humanoid then humanoid.Jump = false end
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(CHECK_INTERVAL)
        end
    end
    
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
    
    -- Return home
    if statusParagraph then statusParagraph:SetDesc("Returning home...") end
    smartMove({Position = HOME_POSITION.Position}, {Value = true}, TWEEN_SPEED, statusParagraph)
    
    return true
end

-- ===================== AUTO FARM BRAINROOT =====================
local function autoFarmBrainroot(rarity, statusParagraph)
    local gapName = nil
    for g, r in pairs(GAP_TO_RARITY) do 
        if r == rarity then 
            gapName = g 
            break 
        end 
    end
    
    if not gapName then 
        if statusParagraph then statusParagraph:SetDesc("Invalid rarity selected") end
        return false 
    end
    
    local targetGapData = nil
    for _, g in ipairs(GAPS) do 
        if g.Name == gapName then 
            targetGapData = g 
            break 
        end 
    end
    
    if not targetGapData then 
        if statusParagraph then statusParagraph:SetDesc("Gap not found for rarity: " .. rarity) end
        return false 
    end
    
    local flag = {Value = true}
    if statusParagraph then statusParagraph:SetDesc("Moving to " .. gapName .. "...") end
    
    local success = smartMove(targetGapData, flag, TWEEN_SPEED, statusParagraph)
    if not success then 
        if statusParagraph then statusParagraph:SetDesc("Failed to reach gap") end
        return false 
    end
    
    if not waitForBrainroot(rarity) then 
        if statusParagraph then statusParagraph:SetDesc("No brainroot spawned yet") end
        return false 
    end
    
    local targetBrainroot, income = getHighestIncomeBrainroot(rarity)
    if not targetBrainroot then 
        if statusParagraph then statusParagraph:SetDesc("No brainroot found") end
        return false 
    end
    
    if statusParagraph then statusParagraph:SetDesc("Found brainroot with $" .. income .. "/s") end
    
    return collectBrainroot(targetBrainroot, statusParagraph)
end

-- ===================== WINDUI SETUP =====================
local WindUI
local maxRetries = 2
for attempt = 1, maxRetries do
    local success, result = pcall(function()
        return loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"))()
    end)
    
    if success and result then
        WindUI = result
        break
    end
end

if not WindUI then
    WindUI = {
        Notify = function(options)
            StarterGui:SetCore("SendNotification", {
                Title = options.Title or "Notification",
                Text = options.Content or "",
                Duration = options.Duration or 3
            })
        end
    }
end

-- ESP Variables
local brainrootEspEnabled = false
local playerEspEnabled = false
local luckyBlockEspEnabled = false
local espObjects = {}
local espLabels = {}
local selectedFloorsForEsp = {"Common Floor", "Uncommon Floor", "Rare Floor", "Epic Floor", "Legendary Floor", "Mythical Floor", "Cosmic Floor", "Secret Floor", "Celestial Floor"}
local selectedLuckyBlockRarities = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythical", "Cosmic", "Secret", "Celestial", "Divine"}
local espUpdateConnection = nil
local brainrootMonitorConnection = nil

local luckyBlockColors = {
    ["Common"] = Color3.fromRGB(170,170,170),
    ["Uncommon"] = Color3.fromRGB(85,255,85),
    ["Rare"] = Color3.fromRGB(85,170,255),
    ["Epic"] = Color3.fromRGB(170,85,255),
    ["Legendary"] = Color3.fromRGB(255,170,0),
    ["Mythical"] = Color3.fromRGB(255,85,85),
    ["Cosmic"] = Color3.fromRGB(0,255,255),
    ["Secret"] = Color3.fromRGB(255,255,255),
    ["Celestial"] = Color3.fromRGB(255,0,255),
    ["Divine"] = Color3.fromRGB(204, 153, 0)
}

local rarityColors = {
    ["Common"] = Color3.fromRGB(0, 255, 0),
    ["Uncommon"] = Color3.fromRGB(0, 195, 255),
    ["Rare"] = Color3.fromRGB(0, 100, 255),
    ["Epic"] = Color3.fromRGB(180, 0, 255),
    ["Legendary"] = Color3.fromRGB(255, 215, 0),
    ["Mythical"] = Color3.fromRGB(200, 0, 255),
    ["Secret"] = Color3.fromRGB(255, 105, 180),
    ["Cosmic"] = Color3.fromRGB(0, 255, 255),
    ["Celestial"] = Color3.fromRGB(255, 255, 200)
}

-- Variables
local flyEnabled = false
local flying = false
local speed = 50
local flyConnection = nil

-- Auto Farm Variables
local collectMoneyEnabled = false
local upgradeBrainrotEnabled = false
local selectedUpgradeSlots = {}
local rebirthEnabled = false
local sellBrainrootEnabled = false
local sellAllEnabled = false
local upgradeBaseEnabled = false

-- Auto Farm Brainroot Variables
local autoFarmBrainrootEnabled = false
local selectedRarity = "Common"

-- Auto Spin Wheel Variables
local autoSpinEnabled = false
local spinCooldown = 1

-- Hitbox Variables
local hitboxEnabled = false
local hitboxSize = 5
local hitboxColor = Color3.new(1, 0, 0)
local hitboxTransparency = 0.7
local hitboxParts = {}

-- Anti-Ragdoll Variables
local antiRagdollEnabled = false
local humanoidStateConn = nil

-- Remote Detection
local plotUUID = nil
local remoteEvent = nil
local lastAction = ""
local lastUUID = ""
local lastSlot = ""

-- Teleport
local selectedBrainrootType = "Common"
local selectedBrainrootIncome = ""
local brainrootTypes = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythical", "Secret", "Cosmic", "Celestial"}
local brainrootNames = {}
local brainrootIncomeList = {}
local teleportMode = "Tween"

-- Floor positions
local floorPositions = {
    {name = "Home / Spawn", cf = CFrame.new(121, 3, 39)},
    {name = "Common Floor", cf = CFrame.new(199, -3, -1)},
    {name = "Uncommon Floor", cf = CFrame.new(284, -3, -5)},
    {name = "Rare Floor", cf = CFrame.new(397, -3, 3)},
    {name = "Epic Floor", cf = CFrame.new(540, -3, -2)},
    {name = "Legendary Floor", cf = CFrame.new(757, -3, 1)},
    {name = "Mythical Floor", cf = CFrame.new(1072,-3, -6)},
    {name = "Cosmic Floor", cf = CFrame.new(1572,-3, 7)},
    {name = "Secret Floor", cf = CFrame.new(2254,-3, 8)},
    {name = "Celestial Floor", cf = CFrame.new(2633,-3, 12)},
}
local currentFloorIndex = 1
local floorStatus = nil

-- Initialize selected slots
for i = 1, 30 do
    table.insert(selectedUpgradeSlots, tostring(i))
end

-- Find remote function
local function findPlotRemote()
    local success, remote = pcall(function()
        return RS.Packages.Net["RF/Plot.PlotAction"]
    end)
    
    if success and remote then
        remoteEvent = remote
        return true
    end
    return false
end

-- UUID capture hook
local old
old = hookmetamethod(game, "__namecall", function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    if method == "InvokeServer" and self == remoteEvent then
        if args[1] == "Collect Money" then
            if typeof(args[2]) == "string" and #args[2] > 10 then
                if plotUUID ~= args[2] then
                    plotUUID = args[2]
                    lastAction = args[1]
                    lastUUID = args[2]
                    lastSlot = args[3] and tostring(args[3]) or "?"
                end
            end
        end
    end

    return old(self, ...)
end)

-- Helper function to extract income from brainroot
local function getBrainrootIncome(brainroot)
    for _, child in ipairs(brainroot:GetDescendants()) do
        if child:IsA("TextLabel") and child.Text:find("%$") then
            local amount = child.Text:match("%$(.+)%/s")
            if amount then 
                return amount
            end
        end
    end
    return "0"
end

local function getBrainrootMutation(brainroot)
    local handle = brainroot:FindFirstChild("Handle")
    if handle then
        local statsGui = handle:FindFirstChild("StatsGui")
        if statsGui then
            local frame = statsGui:FindFirstChild("Frame")
            if frame then
                local mutationLabel = frame:FindFirstChild("Mutation")
                if mutationLabel and mutationLabel:IsA("TextLabel") and mutationLabel.Text ~= "" then
                    return mutationLabel.Text
                end
            end
        end
    end
    
    for _, child in ipairs(brainroot:GetDescendants()) do
        if child:IsA("TextLabel") then
            local text = child.Text:lower()
            if text:find("mutation") or text:find("mut") and child.Text ~= "" then
                return child.Text
            end
        end
    end
    
    return "No Mutation"
end

local function updateBrainrootNames()
    brainrootNames = {}
    brainrootIncomeList = {}
    for _, brainType in ipairs(brainrootTypes) do
        brainrootNames[brainType] = {}
        brainrootIncomeList[brainType] = {}
        local brainroots = Workspace:FindFirstChild("ActiveBrainrots")
        if brainroots then
            local brainTypeFolder = brainroots:FindFirstChild(brainType)
            if brainTypeFolder then
                for _, brainroot in pairs(brainTypeFolder:GetChildren()) do
                    if brainroot:IsA("Model") then
                        local income = getBrainrootIncome(brainroot)
                        local incomeString = "$" .. income .. "/s"
                        
                        table.insert(brainrootNames[brainType], incomeString)
                        table.insert(brainrootIncomeList[brainType], income)
                    end
                end
            end
        end
    end
end

-- Helper functions
local function GetHRP()
    local char = player.Character
    if char then return char:FindFirstChild("HumanoidRootPart") end
end

local function GetHum()
    return player.Character and player.Character:FindFirstChildOfClass("Humanoid")
end

local function TweenTP(pos)
    local hrp = GetHRP()
    local hum = GetHum()
    if not hrp or not hum then return false end
  
    hum:ChangeState(Enum.HumanoidStateType.PlatformStanding)
  
    local time = 1.0
    local targetCFrame = CFrame.new(pos)
  
    local tween = TweenService:Create(hrp, TweenInfo.new(time, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {CFrame = targetCFrame})
    tween:Play()
    tween.Completed:Wait()
  
    hum:ChangeState(Enum.HumanoidStateType.PlatformStanding)
  
    return true
end

local function InstantTP(pos)
    local hrp = GetHRP()
    if hrp then 
        hrp.CFrame = CFrame.new(pos)
        return true
    end
    
    return false
end

local function TeleportTo(pos)
    if teleportMode == "Tween" then
        return TweenTP(pos)
    else
        return InstantTP(pos)
    end
end

local function teleportToBrainroot(brainType, income)
    local brainroots = Workspace:FindFirstChild("ActiveBrainrots")
    if not brainroots then return false end
    
    local folder = brainroots:FindFirstChild(brainType)
    if folder then
        for _, brain in pairs(folder:GetChildren()) do
            if brain:IsA("Model") then
                local brainIncome = getBrainrootIncome(brain)
                if brainIncome == income then
                    return collectBrainroot(brain, nil)
                end
            end
        end
    end
    
    return false
end

-- Auto Farm Functions
local function collectMoney(slot)
    if plotUUID and remoteEvent then
        local success, err = pcall(function()
            remoteEvent:InvokeServer("Collect Money", plotUUID, tostring(slot))
        end)
    end
end

local function startCollectMoneyLoop()
    task.spawn(function()
        while collectMoneyEnabled do
            if plotUUID then
                for i = 1, 30, 5 do
                    if not collectMoneyEnabled then break end
                    
                    for j = i, math.min(i + 4, 30) do
                        task.spawn(function()
                            collectMoney(j)
                        end)
                    end
                    
                    task.wait(0.05)
                end
            end
            task.wait(0.1)
        end
    end)
end

local function upgradeBrainroot(slot)
    if plotUUID and remoteEvent then
        local success, err = pcall(function()
            remoteEvent:InvokeServer("Upgrade Brainrot", plotUUID, tostring(slot))
        end)
        return success
    end
    return false
end

local function startUpgradeBrainrootLoop()
    task.spawn(function()
        while upgradeBrainrotEnabled do
            if plotUUID then
                for i = 1, #selectedUpgradeSlots, 5 do
                    if not upgradeBrainrotEnabled then break end
                    
                    for j = i, math.min(i + 4, #selectedUpgradeSlots) do
                        if selectedUpgradeSlots[j] then
                            task.spawn(function()
                                upgradeBrainroot(selectedUpgradeSlots[j])
                            end)
                        end
                    end
                    
                    task.wait(0.1)
                end
            end
            task.wait(0.5)
        end
    end)
end

local function rebirth() 
    local success = pcall(function()
        RS.RemoteFunctions.Rebirth:InvokeServer()
    end)
    
    if not success then
        WindUI:Notify({
            Title = "Error",
            Content = "Failed to rebirth",
            Duration = 2
        })
    end
end

local function startRebirthLoop()
    task.spawn(function()
        while rebirthEnabled do 
            rebirth()
            task.wait(1.5)
        end
    end)
end

local function sellBrainroot() 
    RS.RemoteFunctions.SellTool:InvokeServer() 
end

local function startSellBrainrootLoop()
    task.spawn(function()
        while sellBrainrootEnabled do 
            sellBrainroot()
            task.wait(0.2)
        end
    end)
end

local function sellAll() 
    RS.RemoteFunctions.SellAll:InvokeServer() 
end

local function startSellAllLoop()
    task.spawn(function()
        while sellAllEnabled do 
            sellAll()
            task.wait(1)
        end
    end)
end

local function checkPrice() 
    return RS.RemoteFunctions.GetSellAmount:InvokeServer() 
end

local function upgradeBase() 
    local success = pcall(function()
        RS.RemoteFunctions.UpgradeBase:InvokeServer()
    end)
    
    if not success then
        WindUI:Notify({
            Title = "Error",
            Content = "Failed to upgrade base",
            Duration = 2
        })
    end
end

local function startUpgradeBaseLoop()
    task.spawn(function()
        while upgradeBaseEnabled do 
            upgradeBase()
            task.wait(1.5)
        end
    end)
end

-- Auto Spin Wheel Function
local function spinWheel()
    local success = pcall(function()
        RS.Packages.Net["RF/WheelSpin.Roll"]:InvokeServer()
    end)
    
    if not success then
        WindUI:Notify({
            Title = "Error",
            Content = "Failed to spin wheel",
            Duration = 2
        })
    end
end

local function startAutoSpinLoop()
    task.spawn(function()
        while autoSpinEnabled do 
            spinWheel()
            task.wait(spinCooldown)
        end
    end)
end

-- Hitbox Functions
local function createHitbox(player)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    
    local hrp = player.Character.HumanoidRootPart
    local character = player.Character
    
    local hitboxPart = Instance.new("Part")
    hitboxPart.Name = "CustomHitbox"
    hitboxPart.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
    hitboxPart.Transparency = hitboxTransparency
    hitboxPart.Color = hitboxColor
    hitboxPart.Material = "Neon"
    hitboxPart.CanCollide = false
    hitboxPart.Anchored = false
    hitboxPart.Massless = true
    
    local weld = Instance.new("WeldConstraint")
    weld.Part0 = hrp
    weld.Part1 = hitboxPart
    weld.Parent = hitboxPart
    
    hitboxPart.CFrame = hrp.CFrame
    hitboxPart.Parent = character
    
    hitboxParts[player.UserId] = hitboxPart
    
    return hitboxPart
end

local function updateHitboxes()
    for userId, part in pairs(hitboxParts) do
        local player = Players:GetPlayerByUserId(userId)
        if not player or not player.Character then
            if part and part.Parent then
                part:Destroy()
            end
            hitboxParts[userId] = nil
        end
    end
    
    if not hitboxEnabled then return end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if not hitboxParts[player.UserId] then
                createHitbox(player)
            else
                local hitbox = hitboxParts[player.UserId]
                if hitbox and hitbox.Parent then
                    hitbox.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                    hitbox.Transparency = hitboxTransparency
                    hitbox.Color = hitboxColor
                else
                    createHitbox(player)
                end
            end
        end
    end
end

local function startHitboxLoop()
    task.spawn(function()
        while hitboxEnabled do
            updateHitboxes()
            task.wait(0.1)
        end
    end)
end

local function clearHitboxes()
    for userId, part in pairs(hitboxParts) do
        if part and part.Parent then
            part:Destroy()
        end
    end
    hitboxParts = {}
end

-- Anti-Ragdoll Functions
local function enableAntiRagdoll()
    if not player.Character or not player.Character:FindFirstChildOfClass("Humanoid") then return end
    
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    
    humanoidStateConn = humanoid.StateChanged:Connect(function(oldState, newState)
        if antiRagdollEnabled and newState == Enum.HumanoidStateType.Ragdoll then
            humanoid:ChangeState(Enum.HumanoidStateType.Running)
        end
    end)
end

local function disableAntiRagdoll()
    if humanoidStateConn then
        humanoidStateConn:Disconnect()
        humanoidStateConn = nil
    end
end

-- Extra Life Functions
local extraLifeEnabled = false
local extraLifeConnection = nil

local function applyAntiDie(character)
    if extraLifeConnection then
        extraLifeConnection:Disconnect()
        extraLifeConnection = nil
    end

    local humanoid = character:WaitForChild("Humanoid")

    humanoid.BreakJointsOnDeath = false
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)

    extraLifeConnection = RunService.Heartbeat:Connect(function()
        if humanoid.Health <= 0 then
            humanoid.Health = humanoid.MaxHealth
            humanoid:ChangeState(Enum.HumanoidStateType.Running)
        end
    end)
end

local function toggleExtraLife(state)
    extraLifeEnabled = state
    
    if state then
        if player.Character then
            applyAntiDie(player.Character)
        end
        
        player.CharacterAdded:Connect(applyAntiDie)
        
        WindUI:Notify({
            Title = "Extra Life",
            Content = "Extra life enabled! You will not die.",
            Duration = 3
        })
    else
        if extraLifeConnection then
            extraLifeConnection:Disconnect()
            extraLifeConnection = nil
        end
        
        if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            humanoid.BreakJointsOnDeath = true
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, true)
        end
        
        WindUI:Notify({
            Title = "Extra Life",
            Content = "Extra life disabled!",
            Duration = 3
        })
    end
end

-- Server Management Functions
local function getServerId()
    local jobId = game.JobId
    return jobId
end

local function copyServerId()
    local jobId = getServerId()
    setclipboard(jobId)
    WindUI:Notify({
        Title = "Server ID",
        Content = "Server ID copied to clipboard!",
        Duration = 2
    })
end

local function joinServer(jobId)
    if jobId and jobId ~= "" then
        TeleportService:TeleportToPlaceInstance(game.PlaceId, jobId)
        WindUI:Notify({
            Title = "Server Join",
            Content = "Attempting to join server...",
            Duration = 2
        })
    else
        WindUI:Notify({
            Title = "Error",
            Content = "Invalid server ID",
            Duration = 2
        })
    end
end

-- Server Hop Functions using provided scripts
local function serverHop()
    loadstring(game:HttpGet("https://pastebin.com/raw/YziSRkcG"))()
end

local function serverHopLowerPlayer()
    loadstring(game:HttpGet("https://pastebin.com/raw/Es8YyHrX"))()
end

local function rejoinServer()
    loadstring(game:HttpGet("https://pastebin.com/raw/aGautz9T"))()
end

-- Backpack Info Functions
local backpackInfoParagraph = nil
local backpackRefreshConnection = nil

local function updateBackpackInfo()
    if not backpackInfoParagraph then return end
    
    local items = {}
    for _, tool in ipairs(player.Backpack:GetChildren()) do
        local rm = tool:FindFirstChild("RenderModel")
        if rm then
            local name = rm:GetAttribute("BrainrotName") or tool.Name
            local mutation = rm:GetAttribute("Mutation") or "None"
            local level = rm:GetAttribute("Level") or 1
            table.insert(items, string.format("%s | %s | Lv.%d", name, mutation, level))
        end
    end
    
    if #items > 0 then
        backpackInfoParagraph:SetDesc(table.concat(items, "\n"))
    else
        backpackInfoParagraph:SetDesc("No brainroots in backpack")
    end
end

local function startBackpackRefresh()
    if backpackRefreshConnection then return end
    
    backpackRefreshConnection = task.spawn(function()
        while true do
            if backpackInfoParagraph then
                updateBackpackInfo()
            end
            task.wait(5)
        end
    end)
end

local function teleportToFloor(index)
    if index < 1 or index > #floorPositions then return false end
    local targetPos = floorPositions[index].cf.Position + Vector3.new(0, 3, 0)
    local success = TeleportTo(targetPos)
    if success then
        currentFloorIndex = index
        WindUI:Notify({
            Title = "Floor Teleport",
            Content = "Moved to: " .. floorPositions[index].name,
            Duration = 2.5
        })
    end
    return success
end

-- ESP SYSTEM
local function calculateDistance(part)
    local hrp = GetHRP()
    if not hrp or not part then return 0 end
    local pos = part.PrimaryPart and part.PrimaryPart.Position or part.Position
    return math.floor((hrp.Position - pos).Magnitude)
end

local function createEspHighlight(part, color)
    local highlight = Instance.new("Highlight")
    highlight.FillColor = color
    highlight.OutlineColor = color
    highlight.FillTransparency = 0.3
    highlight.OutlineTransparency = 0
    highlight.Parent = part
    return highlight
end

local function createEspLabel(part, text, textColor)
    local billboard = Instance.new("BillboardGui")
    billboard.Size = UDim2.new(0, 180, 0, 40)
    billboard.StudsOffset = Vector3.new(0, 2, 0)
    billboard.AlwaysOnTop = true
    billboard.Parent = part

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = textColor
    label.TextStrokeTransparency = 0.5
    label.TextScaled = true
    label.Font = Enum.Font.SourceSansBold
    label.RichText = true
    label.Parent = billboard

    return billboard, label
end

local function cleanupEspObjects()
    for _, obj in pairs(espObjects) do
        if obj and obj.Parent then
            obj:Destroy()
        end
    end
    espObjects = {}
    espLabels = {}
    
    if espUpdateConnection then
        espUpdateConnection:Disconnect()
        espUpdateConnection = nil
    end
end

local function clearEsp()
    cleanupEspObjects()
end

local function getBrainrootInfo(brainroot)
    local name = "Brainroot"
    local moneyPerSec = "??"
    local mutation = "None"
    local mutationColorHex = "CCCCCC"

    for _, child in ipairs(brainroot:GetDescendants()) do
        if child:IsA("TextLabel") and child.Text:find("%$") then
            local amount = child.Text:match("%$(.+)%/s")
            if amount then 
                moneyPerSec = amount
            end
        end
    end

    local handle = brainroot:FindFirstChild("Handle")
    if handle then
        local statsGui = handle:FindFirstChild("StatsGui")
        if statsGui then
            local frame = statsGui:FindFirstChild("Frame")
            if frame then
                local mutationLabel = frame:FindFirstChild("Mutation")
                if mutationLabel and mutationLabel:IsA("TextLabel") and mutationLabel.Text ~= "" then
                    mutation = mutationLabel.Text
                    local c = mutationLabel.TextColor3
                    mutationColorHex = string.format("%02X%02X%02X",
                        math.clamp(math.floor(c.R * 255), 0, 255),
                        math.clamp(math.floor(c.G * 255), 0, 255),
                        math.clamp(math.floor(c.B * 255), 0, 255)
                    )
                end
            end
        end
    end

    return {
        name = name,
        moneyPerSec = moneyPerSec,
        mutation = mutation,
        mutationColorHex = mutationColorHex
    }
end

local function setupBrainrootEsp()
    if not brainrootEspEnabled then return end

    local brainroots = Workspace:FindFirstChild("ActiveBrainrots")
    if not brainroots then return end

    local floorToType = {
        ["Common Floor"] = "Common", ["Uncommon Floor"] = "Uncommon",
        ["Rare Floor"] = "Rare", ["Epic Floor"] = "Epic",
        ["Legendary Floor"] = "Legendary", ["Mythical Floor"] = "Mythical",
        ["Cosmic Floor"] = "Cosmic", ["Secret Floor"] = "Secret",
        ["Celestial Floor"] = "Celestial"
    }

    for _, floorName in ipairs(selectedFloorsForEsp) do
        local brainType = floorToType[floorName]
        if brainType then
            local folder = brainroots:FindFirstChild(brainType)
            if folder then
                for _, brain in pairs(folder:GetChildren()) do
                    if brain:IsA("Model") and brain.Parent then
                        local alreadyExists = false
                        for _, data in ipairs(espLabels) do
                            if data.Type == "Brainroot" and data.BrainType == brainType and data.Part == brain then
                                alreadyExists = true
                                break
                            end
                        end
                        
                        if not alreadyExists then
                            local info = getBrainrootInfo(brain)
                            local baseColor = rarityColors[brainType] or Color3.new(1, 1, 1)
                            local textColor = brainType == "Mythical" and Color3.new(1, 1, 1) or baseColor

                            local highlight = createEspHighlight(brain, baseColor)
                            local billboard, label = createEspLabel(brain, "", textColor)

                            table.insert(espObjects, highlight)
                            table.insert(espObjects, billboard)
                            table.insert(espLabels, {
                                Type = "Brainroot",
                                Part = brain,
                                Label = label,
                                BrainType = brainType,
                                MoneyPerSec = info.moneyPerSec,
                                Mutation = info.mutation,
                                MutationColorHex = info.mutationColorHex
                            })
                        end
                    end
                end
            end
        end
    end
end

local function getRarity(name)
    for rarity,_ in pairs(luckyBlockColors) do
        if string.find(name, rarity) then
            return rarity
        end
    end
end

local function createLuckyBlockESP(obj)
    if obj:FindFirstChild("LuckyBlockESP") then return end

    local rarity = getRarity(obj.Name)
    if not rarity or not table.find(selectedLuckyBlockRarities, rarity) then return end

    local gui = Instance.new("BillboardGui")
    gui.Name = "LuckyBlockESP"
    gui.Size = UDim2.new(0,220,0,55)
    gui.StudsOffset = Vector3.new(0,3,0)
    gui.AlwaysOnTop = true
    gui.Parent = obj

    local text = Instance.new("TextLabel")
    text.Size = UDim2.fromScale(1,1)
    text.BackgroundTransparency = 1
    text.TextScaled = true
    text.Font = Enum.Font.GothamBold
    text.TextStrokeTransparency = 0
    text.TextStrokeColor3 = Color3.new(0,0,0)
    text.TextColor3 = luckyBlockColors[rarity]
    text.Text = "Lucky Block\n["..rarity.."]"
    text.Parent = gui
    
    local highlight = createEspHighlight(obj, luckyBlockColors[rarity])
    table.insert(espObjects, highlight)
    table.insert(espObjects, gui)
    table.insert(espLabels, {
        Type = "LuckyBlock",
        Part = obj,
        Label = text,
        Rarity = rarity,
        ESPGui = gui
    })
end

local function setupLuckyBlockEsp()
    if not luckyBlockEspEnabled then return end

    local LuckyFolder = Workspace:FindFirstChild("ActiveLuckyBlocks")
    if not LuckyFolder then return end

    for _,obj in ipairs(LuckyFolder:GetChildren()) do
        createLuckyBlockESP(obj)
    end
end

local function updateEspDistances()
    local toRemove = {}
    
    for i, data in ipairs(espLabels) do
        if not data.Part or not data.Part.Parent or not data.Label or not data.Label.Parent then
            table.insert(toRemove, i)
        else
            if data.Type == "Brainroot" then
                local dist = calculateDistance(data.Part)
                
                local mutationTag = ""
                if data.Mutation ~= "None" then
                    mutationTag = "<font color=\"#" .. data.MutationColorHex .. "\">[" .. data.Mutation .. "]</font>"
                end
                
                local moneyTag = "<font color=\"#00FF00\">$" .. data.MoneyPerSec .. "/s</font>"

                local mainText = string.format(
                    "%s - %s %s [%dm]",
                    data.BrainType,
                    moneyTag,
                    mutationTag,
                    dist
                )

                data.Label.Text = mainText
            elseif data.Type == "Player" then
                local dist = calculateDistance(data.Part)
                data.Label.Text = string.format("%s [%dm]", data.Player.Name, dist)
            elseif data.Type == "LuckyBlock" then
                local dist = calculateDistance(data.Part)
                if data.ESPGui then
                    data.Label.Text = "Lucky Block\n["..data.Rarity.."] ["..dist.."m]"
                else
                    data.Label.Text = string.format("%s Lucky Block [%dm]", data.Rarity, dist)
                end
            end
        end
    end
    
    for i = #toRemove, 1, -1 do
        local idx = toRemove[i]
        local obj1Index = (idx * 2) - 1
        local obj2Index = idx * 2
        
        if espObjects[obj1Index] and espObjects[obj1Index].Parent then 
            espObjects[obj1Index]:Destroy() 
        end
        if espObjects[obj2Index] and espObjects[obj2Index].Parent then 
            espObjects[obj2Index]:Destroy() 
        end
        
        table.remove(espObjects, obj2Index)
        table.remove(espObjects, obj1Index)
        table.remove(espLabels, idx)
    end
end

local function updateEsp()
    if espUpdateConnection then
        espUpdateConnection:Disconnect()
        espUpdateConnection = nil
    end
    
    clearEsp()
    
    if brainrootEspEnabled then setupBrainrootEsp() end
    if playerEspEnabled then updatePlayerEsp() end
    if luckyBlockEspEnabled then setupLuckyBlockEsp() end
    
    if #espLabels > 0 then
        espUpdateConnection = RunService.Heartbeat:Connect(updateEspDistances)
    end
end

local function startEspMonitoring()
    if brainrootMonitorConnection then
        brainrootMonitorConnection:Disconnect()
        brainrootMonitorConnection = nil
    end

    if not brainrootEspEnabled and not luckyBlockEspEnabled then return end

    brainrootMonitorConnection = RunService.Heartbeat:Connect(function()
        local shouldUpdate = false

        if brainrootEspEnabled then
            local brainroots = Workspace:FindFirstChild("ActiveBrainrots")
            if brainroots then
                local existing = {}
                for _, d in ipairs(espLabels) do
                    if d.Type == "Brainroot" then
                        if not existing[d.BrainType] then existing[d.BrainType] = {} end
                        existing[d.BrainType][d.Part] = true
                    end
                }

                local floorToType = {
                    ["Common Floor"] = "Common", ["Uncommon Floor"] = "Uncommon",
                    ["Rare Floor"] = "Rare", ["Epic Floor"] = "Epic",
                    ["Legendary Floor"] = "Legendary", ["Mythical Floor"] = "Mythical",
                    ["Cosmic Floor"] = "Cosmic", ["Secret Floor"] = "Secret",
                    ["Celestial Floor"] = "Celestial"
                }

                for _, floorName in ipairs(selectedFloorsForEsp) do
                    local brainType = floorToType[floorName]
                    if brainType then
                        local folder = brainroots:FindFirstChild(brainType)
                        if folder then
                            for _, brain in pairs(folder:GetChildren()) do
                                if brain:IsA("Model") and brain.Parent then
                                    if not existing[brainType] or not existing[brainType][brain] then
                                        shouldUpdate = true
                                        break
                                    end
                                end
                            end
                            if shouldUpdate then break end
                        end
                    end
                    if shouldUpdate then break end
                end
            end
        end
        
        if luckyBlockEspEnabled and not shouldUpdate then
            local LuckyFolder = Workspace:FindFirstChild("ActiveLuckyBlocks")
            if LuckyFolder then
                local existing = {}
                for _, d in ipairs(espLabels) do
                    if d.Type == "LuckyBlock" then
                        if not existing[d.Rarity] then existing[d.Rarity] = {} end
                        existing[d.Rarity][d.Part] = true
                    end
                end

                for _, obj in ipairs(LuckyFolder:GetChildren()) do
                    local rarity = getRarity(obj.Name)
                    if rarity and table.find(selectedLuckyBlockRarities, rarity) then
                        if not existing[rarity] or not existing[rarity][obj] then
                            shouldUpdate = true
                            break
                        end
                    end
                    if shouldUpdate then break end
                end
            end
        end

        if shouldUpdate then
            updateEsp()
        end
    end)
end

-- PLAYER ESP
local function createPlayerEsp(player)
    if player == player then return end
    
    local character = player.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    local highlight = createEspHighlight(character, Color3.fromRGB(255, 0, 0))
    local billboard, label = createEspLabel(rootPart, player.Name, Color3.fromRGB(255, 255, 255))
    
    table.insert(espObjects, highlight)
    table.insert(espObjects, billboard)
    table.insert(espLabels, {
        Type = "Player",
        Part = character,
        Label = label,
        Player = player
    })
end

local function updatePlayerEsp()
    if not playerEspEnabled then return end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= player then
            local alreadyExists = false
            for _, data in ipairs(espLabels) do
                if data.Type == "Player" and data.Player == player then
                    alreadyExists = true
                    break
                end
            end
            
            if not alreadyExists and player.Character then
                createPlayerEsp(player)
            end
        end
    end
end

local function togglePlayerEsp(state)
    playerEspEnabled = state
    
    if not state then
        local toRemove = {}
        for i, labelData in ipairs(espLabels) do
            if labelData.Type == "Player" then
                table.insert(toRemove, i)
            end
        end
        
        for i = #toRemove, 1, -1 do
            local index = toRemove[i]
            local labelData = espLabels[index]
            
            if espObjects[(index * 2) - 1] and espObjects[(index * 2) - 1].Parent then
                espObjects[(index * 2) - 1]:Destroy()
            end
            if espObjects[index * 2] and espObjects[index * 2].Parent then
                espObjects[index * 2]:Destroy()
            end
            
            table.remove(espLabels, index)
        end
        
        local newEspObjects = {}
        for _, obj in pairs(espObjects) do
            if obj and obj.Parent then
                table.insert(newEspObjects, obj)
            end
        end
        espObjects = newEspObjects
        
        if #espLabels == 0 and espUpdateConnection then
            espUpdateConnection:Disconnect()
            espUpdateConnection = nil
        end
    else
        updatePlayerEsp()
        
        if not espUpdateConnection then
            espUpdateConnection = RunService.Heartbeat:Connect(updateEspDistances)
        end
    end
end

local function toggleLuckyBlockEsp(state)
    luckyBlockEspEnabled = state
    
    if not state then
        local toRemove = {}
        for i, labelData in ipairs(espLabels) do
            if labelData.Type == "LuckyBlock" then
                table.insert(toRemove, i)
            end
        end
        
        for i = #toRemove, 1, -1 do
            local index = toRemove[i]
            local labelData = espLabels[index]
            
            if espObjects[(index * 2) - 1] and espObjects[(index * 2) - 1].Parent then
                espObjects[(index * 2) - 1]:Destroy()
            end
            if espObjects[index * 2] and espObjects[index * 2].Parent then
                espObjects[index * 2]:Destroy()
            end
            
            table.remove(espLabels, index)
        end
        
        local newEspObjects = {}
        for _, obj in pairs(espObjects) do
            if obj and obj.Parent then
                table.insert(newEspObjects, obj)
            end
        end
        espObjects = newEspObjects
        
        if #espLabels == 0 and espUpdateConnection then
            espUpdateConnection:Disconnect()
            espUpdateConnection = nil
        end
    else
        setupLuckyBlockEsp()
        
        if not espUpdateConnection then
            espUpdateConnection = RunService.Heartbeat:Connect(updateEspDistances)
        end
    end
end

local function setupPlayerEspRespawnHandling()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= player then
            player.CharacterAdded:Connect(function()
                if playerEspEnabled then
                    task.wait(0.5)
                    updatePlayerEsp()
                end
            end)
        end
    end
    
    Players.PlayerAdded:Connect(function(player)
        if playerEspEnabled then
            player.CharacterAdded:Connect(function()
                task.wait(0.5)
                updatePlayerEsp()
            end)
        end
    end)
end

local function toggleBrainrootEsp(state)
    brainrootEspEnabled = state
    if state then
        updateEsp()
        startEspMonitoring()
    else
        if brainrootMonitorConnection then
            brainrootMonitorConnection:Disconnect()
            brainrootMonitorConnection = nil
        end
        local toRemove = {}
        for i, labelData in ipairs(espLabels) do
            if labelData.Type == "Brainroot" then
                table.insert(toRemove, i)
            end
        end
        for i = #toRemove, 1, -1 do
            local index = toRemove[i]
            if espLabels[index].Label and espLabels[index].Label.Parent then
                espLabels[index].Label:Destroy()
            end
            table.remove(espLabels, index)
        end
        updateEsp()
    end
end

local function setupLuckyBlockAutoDetect()
    local LuckyFolder = Workspace:FindFirstChild("ActiveLuckyBlocks")
    if not LuckyFolder then return end
    
    LuckyFolder.ChildAdded:Connect(function(obj)
        if luckyBlockEspEnabled then
            task.wait(0.2)
            createLuckyBlockESP(obj)
        end
    end)
end

-- 
--                                 UI PART
-- 

task.spawn(function()
    if not WindUI or not WindUI.CreateWindow then return end
    task.wait(1)
    updateBrainrootNames()
    findPlotRemote()
    
    -- Theme
    WindUI:AddTheme({
        Name = "Tsunami Theme",
        Accent = Color3.fromRGB(76, 175, 80),
        Dialog = Color3.fromRGB(22, 22, 22),
        Outline = Color3.fromRGB(255, 255, 255),
        Text = Color3.fromRGB(255, 255, 255),
        Placeholder = Color3.fromRGB(122, 122, 122),
        Background = Color3.fromRGB(30, 78, 45),
        Button = Color3.fromRGB(56, 142, 60),
        Icon = Color3.fromRGB(255, 255, 255)
    })
    
    local Window = WindUI:CreateWindow({
        Title = "Cyraa Hub",
        SubTitle = "v1.0.5",
        Folder = "CyraaHub Config",
        NewElements = true,
        Color = Color3.fromRGB(255, 105, 180),
        OpenButton = {
            Title = "by komtolmmek2 script",
            CornerRadius = UDim.new(1,0),
            StrokeThickness = 3,
            Enabled = true,
            Draggable = true,
            OnlyMobile = false,
            Color = ColorSequence.new(
                Color3.fromRGB(48, 255, 106),
                Color3.fromRGB(231, 255, 47)
            ),
            BackgroundColor = Color3.fromRGB(0, 0, 0),
            TextColor = Color3.fromRGB(255, 105, 180),
        },
        Topbar = {
            Height = 44,
            ButtonsType = "Mac",
            Color = Color3.fromRGB(0, 0, 0)
        },
        Size = UDim2.fromOffset(560, 350),
        MinSize = Vector2.new(560, 350),
        MaxSize = Vector2.new(850, 560),
        Transparent = true,
        Theme = "Tsunami Theme",
        Resizable = true,
        SideBarWidth = 200,
        BackgroundImageTransparency = 0.42,
        ScrollBarEnabled = false
    })
    
    Window:Tag({
        Title = "v1.0.5",
        Icon = "github",
        Color = Color3.fromRGB(255, 255, 255),
        Border = true,
    })
    
    Window:Tag({
        Title = "Escape Tsunami For Brainrots!",
        Color = Color3.fromRGB(30, 78, 45),
        Border = true,
    })

    --===[ HOME TAB ]===--
    local homeTab = Window:Tab({ Title = "Home", Icon = "solar:home-2-bold", Color = Color3.fromRGB(255, 105, 180) })
    
    homeTab:Section({ Title = "Update Log" })
    homeTab:Paragraph({ 
        Title = "Version 1.0.5", 
        Desc = "Fixed:\n   - Kembalikan fitur Hitbox dan Anti-Ragdoll\n   - Server Hop menggunakan script pastebin\n   - Auto Farm Brainroot lebih stabil\n   - ESP system fixed\n\nRemoved:\n   - Radioactive Coins Collection\n   - Speed/Jump/Fly dari Settings\n\nKept:\n   - Unlock Camera Zoom button",
    })
    
    homeTab:Section({ Title = "Game Information" })
    
    local GameTimeParagraph = homeTab:Paragraph({
        Title = "Game Time",
        Desc = "0",
        Image = "timer",
        ImageSize = 20
    });
    
    spawn(function()
        while task.wait() do
            pcall(function()
                local GameTime = math.floor(workspace.DistributedGameTime + 0.5);
                local Hour = math.floor(GameTime / 60 ^ 2) % 24;
                local Minute = math.floor(GameTime / 60 ^ 1) % 60;
                local Second = math.floor(GameTime / 60 ^ 0) % 60;
                GameTimeParagraph:SetDesc(Hour .. "h " .. Minute .. "m " .. Second .. "s");
            end);
        end
    end);
    
    local FpsParagraph = homeTab:Paragraph({
        Title = "FPS",
        Desc = "0",
        Image = "monitor",
        ImageSize = 20
    });
    
    spawn(function()
        while task.wait() do
            pcall(function()
                FpsParagraph:SetDesc(math.floor(workspace:GetRealPhysicsFPS()) .. " FPS");
            end);
        end
    end);
    
    homeTab:Section({ Title = "Backpack Information" })
    
    backpackInfoParagraph = homeTab:Paragraph({
        Title = "Brainroot Backpack",
        Desc = "Loading backpack items...",
        Image = "backpack",
        ImageSize = 20
    })
    
    startBackpackRefresh()
    
    homeTab:Section({ Title = "Plot Status" })
    
    local remoteStatusParagraph = homeTab:Paragraph({
        Title = "Collect Money Status",
        Desc = "Waiting for player Collect money...",
        Image = "radar",
        ImageSize = 20
    });
    
    local uuidDisplay = homeTab:Paragraph({
        Title = "Current Plot",
        Desc = "Not detected yet",
        Image = "key",
        ImageSize = 20
    })
    
    local lastActionDisplay = homeTab:Paragraph({
        Title = "Last Detected Action",
        Desc = "None",
        Image = "activity",
        ImageSize = 20
    })
    
    spawn(function()
        while task.wait() do
            pcall(function()
                if plotUUID then
                    remoteStatusParagraph:SetDesc(" Collect Money detected!")
                    uuidDisplay:SetDesc(string.sub(plotUUID, 1, 8) .. "...")
                    lastActionDisplay:SetDesc(lastAction .. " (Slot: " .. lastSlot .. ")")
                else
                    remoteStatusParagraph:SetDesc(" Collect Money not detected yet")
                    uuidDisplay:SetDesc("Not detected yet")
                    lastActionDisplay:SetDesc("None")
                end
            end);
        end
    end)
    
    -- AUTO FARM TAB
    local AutoFarmTab = Window:Tab({Title = "Auto Farm", Icon = "solar:cpu-bold", Color = Color3.fromRGB(255, 105, 180)})
   
    AutoFarmTab:Section({Title = "Auto Farm Brainroot"})
    local autoFarmBrainrootStatus = AutoFarmTab:Paragraph({
        Title = "Status",
        Desc = "Idle",
        Image = "activity",
        ImageSize = 20
    })

    AutoFarmTab:Dropdown({
        Title = "Select Rarity",
        Desc = "Choose the rarity of brainroot to farm",
        Values = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythical", "Cosmic", "Secret", "Celestial"},
        Value = "Common",
        Callback = function(v)
            selectedRarity = v
        end
    })

    AutoFarmTab:Toggle({
        Title = "Auto Farm Brainroot",
        Desc = "Automatically farm the selected rarity brainroot",
        Callback = function(v)
            autoFarmBrainrootEnabled = v
            if v then
                task.spawn(function()
                    autoFarmBrainrootStatus:SetDesc("Starting...")
                    local successCount = 0
                    local failCount = 0
                    
                    while autoFarmBrainrootEnabled do
                        local success = autoFarmBrainroot(selectedRarity, autoFarmBrainrootStatus)
                        if success then
                            successCount = successCount + 1
                            autoFarmBrainrootStatus:SetDesc("Success! (" .. successCount .. " collected)")
                            task.wait(3)
                        else
                            failCount = failCount + 1
                            if failCount > 3 then
                                autoFarmBrainrootStatus:SetDesc("Failed " .. failCount .. " times, checking for brainroot...")
                                waitForBrainroot(selectedRarity)
                                failCount = 0
                            end
                            task.wait(2)
                        end
                    end
                    autoFarmBrainrootStatus:SetDesc("Stopped")
                end)
            else
                autoFarmBrainrootStatus:SetDesc("Stopped")
            end
        end
    })
   
    AutoFarmTab:Section({Title = "Money Collection"})
    AutoFarmTab:Toggle({
        Title = "Auto Collect Money",
        Desc = "Automatically collect money from all slots",
        Callback = function(v) 
            collectMoneyEnabled = v
            
            if v then
                task.spawn(function()
                    task.wait(0.2)
                    if plotUUID then
                        startCollectMoneyLoop()
                        WindUI:Notify({
                            Title = "Auto Collect",
                            Content = "Started collecting money!",
                            Duration = 2
                        })
                    end
                end)
            end 
        end
    })
    
    AutoFarmTab:Section({Title = "Brainroot Upgrade"})
    AutoFarmTab:Toggle({
        Title = "Auto Upgrade Brainroot",
        Desc = "Automatically upgrade brainroots",
        Callback = function(v) 
            upgradeBrainrotEnabled = v
            
            if v then
                task.spawn(function()
                    task.wait(0.2)
                    if plotUUID then
                        startUpgradeBrainrootLoop()
                        WindUI:Notify({
                            Title = "Auto Upgrade",
                            Content = "Started upgrading brainroots!",
                            Duration = 2
                        })
                    end
                end)
            end 
        end
    })
    
    AutoFarmTab:Section({Title = "Progression"})
    AutoFarmTab:Toggle({
        Title = "Auto Rebirth", 
        Desc = "Auto rebirth for money",
        Callback = function(v) 
            rebirthEnabled = v 
            if v then 
                startRebirthLoop()
                WindUI:Notify({
                    Title = "Auto Rebirth",
                    Content = "Started auto rebirth!",
                    Duration = 2
                })
            end 
        end
    })
    
    AutoFarmTab:Toggle({
        Title = "Auto Upgrade Base", 
        Desc = "Auto upgrade base for more slots",
        Callback = function(v) 
            upgradeBaseEnabled = v 
            if v then 
                startUpgradeBaseLoop()
                WindUI:Notify({
                    Title = "Auto Upgrade",
                    Content = "Started upgrading base!",
                    Duration = 2
                })
            end 
        end
    })
    
    -- ESP TAB
    local ESPTab = Window:Tab({Title = "ESP", Icon = "solar:eye-bold", Color = Color3.fromRGB(255, 105, 180)})
    
    ESPTab:Section({Title = "Player ESP"})
    ESPTab:Toggle({
        Title = "Player ESP",
        Desc = "Show players with boxes and names",
        Callback = function(v)
            togglePlayerEsp(v)
            WindUI:Notify({
                Title = "Player ESP",
                Content = v and "Enabled" or "Disabled",
                Duration = 2
            })
        end
    })
    
    ESPTab:Section({Title = "Brainroot ESP"})
    ESPTab:Toggle({
        Title = "Brainroot ESP",
        Desc = "Show brainroots with colors and info",
        Callback = function(v)
            toggleBrainrootEsp(v)
            WindUI:Notify({
                Title = "Brainroot ESP",
                Content = v and "Enabled" or "Disabled",
                Duration = 2
            })
        end
    })
    
    ESPTab:Dropdown({
        Title = "Select Floors for ESP",
        Desc = "Choose which floors to display",
        Values = {"Common Floor", "Uncommon Floor", "Rare Floor", "Epic Floor", "Legendary Floor", "Mythical Floor", "Cosmic Floor", "Secret Floor", "Celestial Floor"},
        Value = selectedFloorsForEsp,
        Multi = true,
        AllowNone = false,
        Callback = function(v)
            selectedFloorsForEsp = v
            if brainrootEspEnabled then
                updateEsp()
            end
        end
    })
    
    ESPTab:Section({Title = "Lucky Block ESP"})
    ESPTab:Toggle({
        Title = "Lucky Block ESP",
        Desc = "Show selected Lucky Blocks with colors",
        Callback = function(v)
            toggleLuckyBlockEsp(v)
            if v then
                setupLuckyBlockAutoDetect()
            end
            WindUI:Notify({
                Title = "Lucky Block ESP",
                Content = v and "Enabled" or "Disabled",
                Duration = 2
            })
        end
    })
    
    ESPTab:Dropdown({
        Title = "Select Lucky Block Rarities",
        Desc = "Choose which Lucky Block rarities to display",
        Values = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythical", "Cosmic", "Secret", "Celestial", "Divine"},
        Value = selectedLuckyBlockRarities,
        Multi = true,
        AllowNone = false,
        Callback = function(v)
            selectedLuckyBlockRarities = v
            if luckyBlockEspEnabled then
                updateEsp()
            end
        end
    })
    
    -- SELL TAB
    local SellTab = Window:Tab({Title = "Sell", Icon = "solar:wallet-money-bold", Color = Color3.fromRGB(255, 105, 180)})
    SellTab:Section({Title = "Sell Options"})
    SellTab:Toggle({
        Title = "Auto Sell Brainroot", 
        Desc = "Automatically sell brainroot in hand",
        Callback = function(v) 
            sellBrainrootEnabled = v
            if v then 
                startSellBrainrootLoop()
                WindUI:Notify({
                    Title = "Auto Sell",
                    Content = "Started selling brainroot!",
                    Duration = 2
                })
            end 
        end
    })
    SellTab:Toggle({
        Title = "Auto Sell All", 
        Desc = "Automatically sell all brainroots",
        Callback = function(v) 
            sellAllEnabled = v
            if v then 
                startSellAllLoop()
                WindUI:Notify({
                    Title = "Auto Sell",
                    Content = "Started selling all!",
                    Duration = 2
                })
            end 
        end
    })

    SellTab:Section({Title = "Wheel Spin"})
    SellTab:Toggle({
        Title = "Auto Spin Wheel", 
        Desc = "Automatically spin the wheel for rewards",
        Callback = function(v) 
            autoSpinEnabled = v
            if v then 
                startAutoSpinLoop()
                WindUI:Notify({
                    Title = "Auto Spin",
                    Content = "Started auto spinning wheel!",
                    Duration = 2
                })
            end 
        end
    })
    SellTab:Slider({
        Title = "Spin Cooldown (seconds)",
        Step = 0.1,
        Value = {Min = 0.5, Max = 5, Default = 1},
        Callback = function(v) 
            spinCooldown = v
        end
    })

    -- TELEPORT TAB
    local TeleportTab = Window:Tab({Title = "Teleport", Icon = "solar:map-bold", Color = Color3.fromRGB(255, 105, 180)})
    
    TeleportTab:Section({Title = "Auto Gap"})
    local selectedGapName = "Gap1"
    local gapFlag = {Value = false}
    local autoGapStatus = TeleportTab:Paragraph({
        Title = "Status",
        Desc = "Idle",
        Image = "activity",
        ImageSize = 20
    })

    TeleportTab:Dropdown({
        Title = "Select Target Gap",
        Desc = "Choose the gap you want to move to",
        Values = {"Gap1", "Gap2", "Gap3", "Gap4", "Gap5", "Gap6", "Gap7", "Gap8", "Gap9"},
        Value = "Gap1",
        Callback = function(v)
            selectedGapName = v
        end
    })

    TeleportTab:Toggle({
        Title = "Auto go to Gap",
        Desc = "Automatically move to the selected gap",
        Callback = function(v)
            gapFlag.Value = v
            if v then
                local targetGapData = nil
                for _, gap in ipairs(GAPS) do
                    if gap.Name == selectedGapName then
                        targetGapData = gap
                        break
                    end
                end

                if targetGapData then
                    task.spawn(function()
                        autoGapStatus:SetDesc("Moving to " .. selectedGapName .. "...")
                        local success = smartMove(targetGapData, gapFlag, TWEEN_SPEED, autoGapStatus)
                        if success then
                            autoGapStatus:SetDesc("Arrived at " .. selectedGapName)
                        else
                            autoGapStatus:SetDesc("Failed to reach " .. selectedGapName)
                        end
                    end)
                else
                    WindUI:Notify({Title = "Error", Content = "Selected gap not found!", Duration = 3})
                    gapFlag.Value = false
                end
            else
                autoGapStatus:SetDesc("Stopped")
            end
        end
    })
    
    TeleportTab:Section({Title = "Teleport Mode"})
    TeleportTab:Dropdown({
        Title = "Teleport Mode",
        Desc = "Choose between Tween or Instant teleport",
        Values = {"Tween", "Instant"},
        Value = "Tween",
        Callback = function(v) 
            teleportMode = v
        end
    })
    
    TeleportTab:Section({Title = "Brainroot Teleport"})
    local typeDD = TeleportTab:Dropdown({
        Title = "Brainroot Type",
        Values = brainrootTypes,
        Value = 1,
        Callback = function(v)
            selectedBrainrootType = v
            updateBrainrootNames()
            if brainrootIncomeList[selectedBrainrootType] and #brainrootIncomeList[selectedBrainrootType] > 0 then
                incomeDD:Refresh(brainrootIncomeList[selectedBrainrootType])
                selectedBrainrootIncome = brainrootIncomeList[selectedBrainrootType][1] or ""
            end
        end
    })
    local incomeDD = TeleportTab:Dropdown({
        Title = "Brainroot Income ($/s)",
        Values = brainrootIncomeList["Common"] or {},
        Value = 1,
        Callback = function(v) 
            selectedBrainrootIncome = v
        end
    })
    TeleportTab:Button({
        Title = "Refresh Brainroot List",
        Callback = function()
            updateBrainrootNames()
            if brainrootIncomeList[selectedBrainrootType] then
                incomeDD:Refresh(brainrootIncomeList[selectedBrainrootType])
            end
            WindUI:Notify({
                Title = "Brainroot List",
                Content = "Brainroot list refreshed",
                Duration = 2
            })
        end
    })
    TeleportTab:Button({
        Title = "Teleport to Selected Brainroot",
        Callback = function()
            if selectedBrainrootIncome ~= "" then
                if teleportToBrainroot(selectedBrainrootType, selectedBrainrootIncome) then
                    WindUI:Notify({
                        Title = "Teleport", 
                        Content = "Teleported to " .. selectedBrainrootType .. " brainroot with $" .. selectedBrainrootIncome .. "/s",
                        Duration = 2
                    })
                else
                    WindUI:Notify({
                        Title = "Error",
                        Content = "Brainroot not found",
                        Duration = 2
                    })
                end
            else
                WindUI:Notify({
                    Title = "Error",
                    Content = "Please select a valid income value",
                    Duration = 2
                })
            end
        end
    })
    
    TeleportTab:Section({Title = "Floor Navigation"})
    floorStatus = TeleportTab:Paragraph({
        Title = "Current Location",
        Desc = floorPositions[1].name,
    })
    TeleportTab:Button({
        Title = " Previous Floor",
        Callback = function()
            if currentFloorIndex > 1 then
                currentFloorIndex = currentFloorIndex - 1
                teleportToFloor(currentFloorIndex)
                floorStatus:SetDesc(floorPositions[currentFloorIndex].name)
            else
                WindUI:Notify({Title = "Floor", Content = "Already at the first floor!", Duration = 2})
            end
        end
    })
    TeleportTab:Button({
        Title = "Next Floor ",
        Callback = function()
            if currentFloorIndex < #floorPositions then
                currentFloorIndex = currentFloorIndex + 1
                teleportToFloor(currentFloorIndex)
                floorStatus:SetDesc(floorPositions[currentFloorIndex].name)
            else
                WindUI:Notify({Title = "Floor", Content = "Already at the last floor!", Duration = 2})
            end
        end
    })
    
    TeleportTab:Button({
        Title = "Reset to Home",
        Callback = function()
            currentFloorIndex = 1
            teleportToFloor(currentFloorIndex)
            floorStatus:SetDesc(floorPositions[currentFloorIndex].name)
            WindUI:Notify({
                Title = "Floor Teleport",
                Content = "Reset to Home",
                Duration = 2
            })
        end
    })
    
    -- SERVER MANAGEMENT TAB
    local ServerTab = Window:Tab({Title = "Server", Icon = "solar:server-bold", Color = Color3.fromRGB(255, 105, 180)})
    
    ServerTab:Section({Title = "Server Information"})
    local serverIdDisplay = ServerTab:Paragraph({
        Title = "Current Server ID",
        Desc = "Loading...",
    })
    
    task.spawn(function()
        while task.wait(1) do
            if serverIdDisplay then
                serverIdDisplay:SetDesc(getServerId())
            end
        end
    end)
    
    ServerTab:Button({
        Title = "Copy Server ID",
        Callback = function()
            copyServerId()
        end
    })
    
    ServerTab:Section({Title = "Server Actions"})
    ServerTab:Button({
        Title = "Rejoin Server",
        Callback = function()
            rejoinServer()
        end
    })
    
    ServerTab:Button({
        Title = "Server Hop (Random)",
        Callback = function()
            serverHop()
        end
    })
    
    ServerTab:Button({
        Title = "Server Hop (Lower Player Count)",
        Callback = function()
            serverHopLowerPlayer()
        end
    })
    
    -- SETTINGS TAB
    local SettingsTab = Window:Tab({Title = "Settings", Icon = "solar:settings-bold", Color = Color3.fromRGB(255, 105, 180)})
    
    SettingsTab:Section({Title = "Camera"})
    SettingsTab:Button({
        Title = "Unlock Camera Zoom",
        Desc = "Remove camera zoom distance limit",
        Callback = function()
            player.CameraMaxZoomDistance = math.huge
            WindUI:Notify({
                Title = "Camera",
                Content = "Camera zoom distance unlocked!",
                Duration = 2
            })
        end
    })
    
    SettingsTab:Section({Title = "Hitbox"})
    SettingsTab:Toggle({
        Title = "Enable Hitbox",
        Desc = "Expand hitboxes of other players",
        Callback = function(v)
            hitboxEnabled = v
            if v then
                startHitboxLoop()
                WindUI:Notify({
                    Title = "Hitbox",
                    Content = "Hitbox enabled!",
                    Duration = 2
                })
            else
                clearHitboxes()
                WindUI:Notify({
                    Title = "Hitbox",
                    Content = "Hitbox disabled!",
                    Duration = 2
                })
            end
        end
    })
    SettingsTab:Slider({
        Title = "Hitbox Size",
        Step = 1,
        Value = {Min = 1, Max = 20, Default = 5},
        Callback = function(v)
            hitboxSize = v
        end
    })
    SettingsTab:Slider({
        Title = "Hitbox Transparency",
        Step = 0.1,
        Value = {Min = 0, Max = 1, Default = 0.7},
        Callback = function(v)
            hitboxTransparency = v
        end
    })
    SettingsTab:Button({
        Title = "Red Hitbox",
        Callback = function()
            hitboxColor = Color3.new(1, 0, 0)
            WindUI:Notify({
                Title = "Hitbox Color",
                Content = "Changed to red!",
                Duration = 2
            })
        end
    })
    SettingsTab:Button({
        Title = "Green Hitbox",
        Callback = function()
            hitboxColor = Color3.new(0, 1, 0)
            WindUI:Notify({
                Title = "Hitbox Color",
                Content = "Changed to green!",
                Duration = 2
            })
        end
    })
    SettingsTab:Button({
        Title = "Blue Hitbox",
        Callback = function()
            hitboxColor = Color3.new(0, 0, 1)
            WindUI:Notify({
                Title = "Hitbox Color",
                Content = "Changed to blue!",
                Duration = 2
            })
        end
    })
    
    SettingsTab:Section({Title = "Protection"})
    SettingsTab:Toggle({
        Title = "Anti-Ragdoll",
        Desc = "Prevent ragdoll state",
        Callback = function(v)
            antiRagdollEnabled = v
            if v then
                enableAntiRagdoll()
                WindUI:Notify({
                    Title = "Anti-Ragdoll",
                    Content = "Anti-ragdoll enabled!",
                    Duration = 2
                })
            else
                disableAntiRagdoll()
                WindUI:Notify({
                    Title = "Anti-Ragdoll",
                    Content = "Anti-ragdoll disabled!",
                    Duration = 2
                })
            end
        end
    })
    
    SettingsTab:Toggle({
        Title = "Extra Life (Beta)",
        Desc = "Prevent death (but you can still die from tsunami)",
        Callback = function(v)
            toggleExtraLife(v)
        end
    })
    
    WindUI:Notify({
        Title = "Cyraa Hub Loaded",
        Content = "Escape Tsunami For Brainrots! v1.0.5 Loaded\nMade by komtolmmek2 script",
        Duration = 4
    })
    
    setupLuckyBlockAutoDetect()
    setupPlayerEspRespawnHandling()
end)

player.CharacterAdded:Connect(function()
    task.delay(1.5, function()
        currentFloorIndex = 1
        if floorStatus then
            floorStatus:SetDesc(floorPositions[currentFloorIndex].name)
        end
        plotUUID = nil
        lastAction = ""
        lastUUID = ""
        lastSlot = ""
        findPlotRemote()
        if brainrootEspEnabled then
            toggleBrainrootEsp(false)
            task.wait(0.1)
            toggleBrainrootEsp(true)
        end
        if playerEspEnabled then
            togglePlayerEsp(false)
            task.wait(0.1)
            togglePlayerEsp(true)
        end
        if luckyBlockEspEnabled then
            toggleLuckyBlockEsp(false)
            task.wait(0.1)
            toggleLuckyBlockEsp(true)
            setupLuckyBlockAutoDetect()
        end
        if antiRagdollEnabled then
            enableAntiRagdoll()
        end
        if hitboxEnabled then
            clearHitboxes()
            task.wait(0.5)
            startHitboxLoop()
        end
        if extraLifeEnabled then
            task.wait(0.5)
            applyAntiDie(player.Character)
        end
        if backpackInfoParagraph then
            updateBackpackInfo()
        end
    end)
end)

print("Script loaded successfully - v1.0.5 by komtolmmek2")
